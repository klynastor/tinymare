&

                  Welcome to the Online TinyMARE Help Manual!

  We are sorry for the inconvienence, but this release of TinyMare is in the
  middle of changing Helptext versions, and not all the topics are imported!
  Please see the url: 'http://www.winds.org/helptext/' for the previous help
  pages, last dated November 14, 2001.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Help on Playing the Game:              Building and Coding Topics:

  Getting Started                        Building Commands
  General Information                    Attributes
  Commands                               Functions
  Combat                                 Flags
 
[1;32mType [37m'help <topic>'[32m where <topic> is an option from the list above,[m
[1;32mor type [37m'help topics'[32m for a complete list of topics.[m

& Topics

Available Help Topics:

  Attributes
  Building Commands
  Combat
* Commands
  Flags
* Functions
* Function List
  Gender
* Getting Started
* General Information
  Matching
  Pronouns
* Timezones
  Wildcards

&& Wizard Topics

Available Wizard Topics:

  Wizard Commands
  System Configuration

Combat Topics:

  Elements
* Pyramid Curve
  Creating Spells
* Spell Attributes
  Spell Messages
* Status Attributes
* Status Attacks

& Getting Started

Getting Started

  Welcome to Northwind Saga! Here are the most common commands you can use to
  control your player character in the Land of the Wind.

  look    => Look at the current room you're in. Shows its contents and exits.
  look x  => Looks at a specific object in the room. Example: [37m'look plant'[32m.
  inv     => Shows your inventory: what you're carrying and how much it weighs.
  take x  => Takes an item from the room. Some objects cannot be picked up.
  drop x  => Drops an item from your inventory into the room.

  These next few commands interact with the other players online. Where you see
  <keyword>, substitute your own message without the <>'s.

  who                  => Lists all the players currently logged into the game.
  page <player>=<msg>  => Sends a <message> to a specific <player name> online.
  say <message>        => Says something to the people in the room you're in.
  =<message>           => Sends a message to everyone on the [public] channel.

  To walk through an exit, type in the exit's name. Example: 'doors'.
  For more information about how the game works, type: 'help general info'.

& General Information

General Information

  The game world consists of a grid of rooms, each connected by exits. Players
  like yourself can traverse the exits to reach a new room by typing in the
  name of the exit. When other players are in the room with you, you can talk
  to them by using the 'say' or 'pose' commands, abbreviated " or : for short.

  Most commands manipulate an object in the room or in your inventory. They are
  of the form 'command x', where x is the name of the object. For example,
  typing 'look desk' will look at the first object in the list named "Desk". If
  two objects are named "Desk", you can type 'look desk 2' to look at the
  second one. The same goes for the other commands.

  Although this is a multi-player game, each person has their own vision of the
  story. Talking to NPCs (non-player characters) can reveal clues on how to
  progress in the storyline, which remains different for every player. Even
  though you may be in the same room as someone else, objects that show up for
  them might not always be in your Contents list.

  Type 'help commands' for a summary of commands the game recognizes. In some
  rooms, some objects might provide additional commands. 'look' or 'talk' to
  these objects to find out what they are.

& Commands

Commands

Set 1: Standard CommandsÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  announce   examine   help       money     put       take     whisper
  clear      exits     inventory  move      run       talk     whereis
  drop       give      leave      page      say       to       who
  enter      grab      look       pose      search    use

Set 2: Out-of-character CommandsÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  +channel   +finger    +motd    +tzone
  +com       +laston    +news    +uptime
  +config    +mail      +term    +version

See also: Building Commands

& Timezones

Timezones

  This game supports and understands a number of timezones across the world. 
  This feature allows you to play the game with all real-life times and dates
  changed to your preferred timezone, and even allows you to display the
  current time as observed by the timezone in another part of the world.

  Your timezone can be changed by using the "+tzone" command. In the game, this
  specifies the number of hours and minutes offset from Universal Coordinated
  Time (Greenwich, England), and determines whether Standard or Daylight
  Savings Time is active in your area. Once set, all time displays such as
  [time()], [xtime()], '+laston', '+uptime', and '+mail' will now report values
  based on your timezone instead of the game's default.

  If you want to see the current time in California, for instance, you do not
  need to set your "+tzone" temporarily. All you need to do is specify the
  timezone as part of the time string using the [time()] function, as in the
  following 2 examples:

  > say [time(PDT)]
  > say [time(Sep 20 15:00:00 PDT)]

Timezone List:

  The MARE understands the following timezones. Note that if your timezone
  supports Daylight Savings Time during the summer, select the version that
  lists the letter 'D' after the hours. 'D' timezones will alternate
  appropriately between Standard and Daylight Savings Time.

East of the Prime Meridian: 

    GMT   +0000   Greenwich Mean
    UTC   +0000   Universal Coordinated
    WET   +0000   Western European
    BST   +0000 D British Summer
    CET   +0100   Central European
    MET   +0100   Middle European
    MEWT  +0100   Middle European Winter
    MEST  +0100 D Middle European Summer
    SWT   +0100   Swedish Winter
    SST   +0100 D Swedish Summer
    FWT   +0100   French Winter
    FST   +0100 D French Summer
    EET   +0200   Eastern Europe
    BT    +0300   Baghdad
    IT    +0330   Iran
    ZP4   +0400   Russia Zone 3
    ZP5   +0500   Russia Zone 4
    IST   +0530   Indian Standard
    ZP6   +0600   Russia Zone 5
    NSUT  +0630   North Sumatra
    WAST  +0700   West Australia Standard
    WADT  +0700 D West Australia Daylight
    SSUT  +0700   South Sumatra
    JT    +0730   Java
    WST   +0800   Western Australia Standard
    WDT   +0800 D Western Australia Daylight
    CCT   +0800   China Coast
    MT    +0830   Moluccas
    JST   +0900   Japan Standard
    KST   +0900   Korea Standard
    CAST  +0930   Central Australian Standard
    CADT  +0930 D Central Australian Daylight
    SAT   +0930   Southern Australian Standard
    SADT  +0930 D Southern Australian Daylight
    EAST  +1000   Eastern Australian Standard
    EADT  +1000 D Eastern Australian Daylight
    GST   +1000   Guam Standard
    NZST  +1200   New Zealand Standard
    NZDT  +1200 D New Zealand Daylight
    NZT   +1200   New Zealand
    IDLE  +1200   International Date Line East

West of the Prime Meridian: 

    WAT   -0100   West Africa
    AT    -0200   Azores
    BRST  -0300   Brazil Standard
    GLST  -0300   Greenland Standard
    NFT   -0330   Newfoundland Standard
    NST   -0330   Newfoundland Standard
    NDT   -0330 D Newfoundland Daylight
    AST   -0400   Atlantic Standard
    ADT   -0400 D Atlantic Daylight
    EST   -0500   Eastern Standard
    EDT   -0500 D Eastern Daylight
    CST   -0600   Central Standard
    CDT   -0600 D Central Daylight
    MST   -0700   Mountain Standard
    MDT   -0700 D Mountain Daylight
    PST   -0800   Pacific Standard
    PDT   -0800 D Pacific Daylight
    YST   -0900   Yukon Standard
    YDT   -0900 D Yukon Daylight
    HST   -1000   Hawaii Standard
    HDT   -1000 D Hawaii Daylight
    AHST  -1000   Alaska-Hawaii Standard
    AHDT  -1000 D Alaska-Hawaii Daylight
    CAT   -1000   Central Alaska
    NT    -1100   Nome
    IDLW  -1200   International Date Line West

See also: +tzone, time()

& Functions

Functions

  Functions are integral to the programming and manipulation of variables and
  strings in the game. This topic describes how to use functions and build
  them into code on your objects.
  
  Type 'help function list' or '@list functions' for a list of available
  functions. Type 'help functionname()' for help on a specific function and
  its syntax.

Function syntax:

  <string>       = Any size string up to 8000 characters long. A string could
                   contain multiple words, spaces, tabs, or nothing at all.

  <word list>    = A list of words separated by a delimiter character (e.g. a
                   space). Each word in the list is acted upon distinctly.

  <integer>      = A positive or negative integer with no decimal point.

  <real number>  = Any positive or negative number, with or without a
                   decimal point.

  <delimiter>    = A single case-sensitive character by which to separate words
                   in a <word list>. The default if unspecified is a space.

  <pattern>      = A string containing wildcards ('*' and '?' characters) that
                   can match multiple words. See 'help wildcards' for details.

  <expression>   = A sub-function whose result is evaluated to affect the
                   outcome of the primary function. Boolean expressions return
                   either True (1) or False (0).

Function invocation:

  A function can be used in two ways. The first way is somewhere in a string
  of text that is parsed by the game, such as in the 'say' command or an
  attribute that is @triggered into the command queue. Such a function is
  specified by surrounding it with square brackets [ ] as in this example:

  > say Two plus four equals [add(2,4)].
  You say, "Two plus four equals 6."

  The second way is to specify the function as the only item in a command
  argument. In this manner, no square brackets are necessary and the function
  is interpreted without any extra parsing. Only commands that do not
  automatically perform %-substitution will allow this (i.e. not 'say' or
  'pose'). It is a good idea to memorize which commands will not allow this
  behavior. The following examples demonstrate this type of invocation:

  @vb me=get(me,va)                     => Copies @va to @vb.

  @trigger me/runstring = mul(8,v(vb))  => Triggers @runstring with %0 set to
                                           8 times the value of %vb.

  @switch v(#)=v(0),{@print Correct.}   => Prints 'Correct.' if %# equals %0.

  The @echo command can be used to test-evaluate functions before using them in
  attributes, like this:

  > @echo [div(12,3)]
  4

Function arguments:

  Arguments in functions are separated by commas. When a function expects two
  or more arguments, then omitting the comma will result in an error. The
  number of arguments for each function varies along with its syntax for the
  function used.

  For example, the function round() allows either 1 or 2 arguments. The
  second argument is optional, defining how many decimal places a number is
  to be rounded, or 0 if omitted. Therefore, the following two functions are
  valid:

  [round(3.14159265)]    => 3
  [round(3.14159265,4)]  => 3.1416

  Arguments can also contain functions themselves. Specifying a function inside
  of a function is the same, except that the [] around the function is omitted.
  Remember, the [] only needs to be specified once for each top-level function
  so the parser understands the following text is not to be represented
  literally. Here is an example using the function [pi()] inside of [round()]:

  [round(pi())]    => 3
  [round(pi(),4)]  => 3.1416

  Some functions, such as add() or fmul(), allow either multiple arguments or
  a space-separated word list for input. Such functions will explain this
  feature in their syntax diagram individually. For these functions, there is
  no limit to the number of arguments except for the number of characters that
  can fit on a line, 8000.

Braces:

  Braces are necessary when specifying an argument that contains a comma, a
  space, a blank string, or padding a string with spaces. A left brace '{' must
  be the first character in the argument, and a right brace '}' must be the
  last. Braces in other locations in the argument will appear in the function
  rather than be stripped out by the parser. Compare the following 1-argument
  substitutions with and without braces:

  [s(Ham sandwich, fries, and a soft drink.)]    => Invalid; 3 arguments.
  [s({Ham sandwich, fries, and a soft drink.})]  => Valid; 1 argument.

  [s( a b  c d )]    => 'a b  c d'
  [s({ a b  c d })]  => ' a b  c d '
  
  [s(abc{d,e}fgh)]   => 'abc{d,e}fgh'  - Valid; 1 argument.
                        The {} in the middle protects the comma from being
                        counted as an argument separator, but the {}'s are not
                        stripped out.

  Braces can also be used to tell the parser to skip processing for a specific
  argument. Functions can literally be printed instead of converted when inside
  braces. In the following example, the s()-substitution function only converts
  the add() when [] symbols surround it inside braces:

  [s({add(2,4)})]    => 'add(2,4)'
  [s({[add(2,4)]})]  => '6'

  Note that it is impossible to write a function which inserts a '{' character
  without its corresponding '}' character, unless you use a second function to
  input its ASCII value, such as [chr(123)]. Here is one way to insert a '{'
  into a string:

  [strcat(abc,chr(123),def)]  => 'abc{def'

Blank arguments:

  Arguments can also be blank. For a function that expects one argument, using
  {} will pass a null string to the function. For a multi-argument function,
  simply using a comma tells the function parser that another argument is
  coming. Compare the following functions:
  
  [s()]         => Invalid; 0 arguments.
  [s({})]       => Valid; 1 argument.

  [ifelse(hasflag(me,dark),{},Viewable)]  => Valid; ifelse() has 3 arguments.
  [ifelse(hasflag(me,dark),,Viewable)]    => Valid; ifelse() has 3 arguments.

Delimiters:

  For most string functions, a delimiter character can be specified as the
  word separator in a list. If the delimiter is a space (' ') character, then
  any number of spaces can be used to separate a word. However if the delimiter
  is any other character, two delimiters without anything between will be
  treated as a blank word. For example:

  [replace(a b  c d,3,C)]    => 'a b  C d'
  [replace(a-b--c-d,3,C,-)]  => 'a-b-C-c-d'

Negating Results:

  The negation of each function can be retrieved by placing a '!' symbol before
  the name of the function. If the result of a function is false--either '0',
  '#-1', or a null string ('')--then a 1 will be returned, otherwise a 0 will
  be returned. This is no different from the not() function. For example:

  [eq(6,3)]   => '0'
  [!eq(6,3)]  => '1'

Function Errors:

  When an error is detected in the processing of a function, an error message
  prefixed with '#-1' is returned and the parser continues on. The message
  describes the type and severity of error that occurred. Because of the '#-1',
  all error results have the boolean value of 'False' unless the function
  itself was negated with not() or '!'. Here are some examples:

  [between(2)]                  => '#-1 Function BETWEEN requires 3 arguments.'
  [get(#1,desc)]                => '#-1 Permission denied.'
  [time(Feb 29 13:15:00 1999)]  => '#-1 Invalid date.'

Efficiency and Optimization:

  All arguments to a function are evaluated before the function is processed.
  Thus, in the function [ifelse(v(0),add(3,4),mul(6,7))] the v(), add(), and
  mul() functions are all evaluated before the ifelse() is even reached. Given
  that %0 equals 6, the function parser predicates the term as [ifelse(6,7,42)]
  and only displays the true portion, 7.

  This is important in working with functions that produce side-effects, such
  as the setq() or setr() environment registers. If the mul() in the above
  example was replaced with a setq(1,10), then %1 will get set to 10
  independent of whether %0 is true or false. In this case, it is better to
  move the setq() outside of the ifelse, as in this example, which only sets
  %1 to 10 if %0 is false (or sets %1 to itself when true):

  [setq(1,ifelse(v(0),v(1),10))]  => Produces no text output, but has the side-
                                     effect of setting %1 to a new value.

  Environment configuration variables FUNC_RECURSION and MAX_FUNCTIONS (in
  @list config) determine how many functions can be called within each other,
  and how many functions can be processed in one command, respectively. If you
  find long lists of foreach() or oper() functions breaking after a set number
  of inputs, try splitting the function up into smaller pieces that can be
  executed by several commands.

  You can use the pronoun %? to determine the function invocation and recursion
  level of the current command, respectively.

See also: Function List

& Function List

The following sets of functions are available for use in MARE.
Type 'help functionname()' for information on each function individually.

Set 1: Basic ArithmeticÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  add()  fadd()  ³  int()     neg()    ³  sin()  asin()  ³  pow()   degrees()
  sub()  fsub()  ³  round()   abs()    ³  cos()  acos()  ³  sqrt()  dist2d()
  mul()  fmul()  ³            sign()   ³  tan()  atan()  ³  ln()    dist3d()
  div()  fdiv()  ³  ceil()             ³                 ³  log()
  mod()  rdiv()  ³  floor()   range()  ³  pi()   e()     ³  exp()   factor()

Set 2: Logic & Binary ArithmeticÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  eq()      neq()   ³  if()      min()  ³  band()   land()  ³  shl()    dec()
  gt()      lt()    ³  ifelse()  max()  ³  bor()    lor()   ³  shr()    inc()
  gteq()    lteq()  ³  iftrue()  avg()  ³  bxor()   lxor()  ³           base()
  ncomp()           ³  truth()          ³  bnand()          ³  ffs()
  between()         ³  not()  stddev()  ³                   ³  bitcount()

Set 3: TinyMARE Runtime ConfigurationÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  mudname()  uptime()     ³   dbtop()     ³   cpu()
  version()  restarts()   ³   upfront()   ³   cputime()
  config()   netstat()    ³               ³

Set 4: Weather AlmanacÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  wtime()      ³  moonphase()  ³  weather()
  wdate()      ³  dayofyear()  ³
  timeofday()  ³  season()     ³

Set 5: Time and Session ManagementÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  time()   tml()  ³  idle()   ³  sessions()  ³  cols()  ³  input()   host()
  date()   tms()  ³  onfor()  ³  steps()     ³  rows()  ³  output()  port()
  rtime()  tmf()  ³  lwho()   ³  age()       ³  term()  ³  cmds()    concid()
  xtime()  tma()  ³  cwho()   ³  gender()    ³          ³  laston()  lastoff()
                                                           ipaddr()

Set 6: Object Matching FunctionsÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  num()       name()      loc()     ³  con()       exit()      linkup()
  pnum()      cname()     link()    ³  lcon()      lexits()    entrances()
  flags()     fullname()  owner()   ³  plcon()     oexit()     inzone()
  unparse()   rmatch()    next()    ³  objlist()   randexit()  zwho()
                                    ³
  type()      room()      zone()    ³  powers()    parents()   subj()
  class()     rloc()      plane()   ³  controls()  children()  objn()
  rank()      nearby()              ³  haspow()    is_a()      poss()
  immortal()  sees()      valid()   ³  hasflag()   has_a()     aposs()

Set 7: Object Attribute RetrievalÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  v()         s()          ³  isattr()    createtime()  ³  stats()
  get()       s_as()       ³  hasattr()   modtime()     ³  objmem()
              s_as_with()  ³  attropts()  pennies()     ³  playmem()
  lattr()                  ³                            ³
  lattrdef()  parse_lock() ³  zoneattr()                ³

Set 8: String UtilitiesÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  strlen()    match()     ³  extract()  insert()   ³  lnum()      flip()
  wcount()    wmatch()    ³  remove()   replace()  ³  repeat()    wordflip()
              matchall()  ³             swap()     ³              scramble()
  capstr()                ³  first()               ³  spc()
  lcstr()     regmatch()  ³  rest()     ljust()    ³  chr()       dice()
  ucstr()     setq()      ³  last()     rjust()    ³  ascii()     rand()
              setr()      ³             center()   ³              randword()
  strcat()                ³  mid()      justify()  ³  esc()
  edit()      trim()      ³  delete()              ³  csi()       switch()
  comp()      secure()    ³  pos()      left()     ³  ansi()      foreach()
              strip()     ³  lpos()     right()    ³              oper()

  art(), pluralize(), isdbref(), isnum(), isword(), sort()
  setdiff(), setinter(), setunion()

You say, "[strprefix(full string,prefix)] returns 1 if <prefix> is a prefix of
<full string>,"
You say, "[prefixall(word list,prefix,[delim])] returns the first word number
that <prefix> is a prefix of in <word list>."

Set 9: Combat SystemÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  chapter()   bitmap()    ³  findsp()    mglvl()
  race()      bitrange()  ³  splist()
  guild()     soul()      ³
                          ³  spattr()
  level()     cond()      ³  template()
  nextexp()   hascond()   ³
  weight()                ³

See also: Functions

& add()

add(<integers>, ...)

  This function adds up a list of integers, either as separate arguments or a
  space-separated list, and prints the sum. Use fadd() if you need to add
  floating-point (decimal) numbers together.

Examples:

  [add(3,4)]             => '7'
  [add(1 2 3 4 5 6)]     => '21'
  [add(10,5 5,1 2 3 4)]  => '30'

See also: div(), mod(), mul(), sub()

& sub()

sub(<integer>, <integer>)

  This function subtracts two integers and returns the difference. Both
  integers must be separate arguments to this function. Use fsub() if you need
  to subtract two floating-point numbers.

Examples:

  [sub(7,4)]      => '3'
  [sub(-18,-40)]  => '22'

See also: add(), div(), mod(), mul()

& mul()

mul(<integers>, ...)

  This function multiplies a list of integers, either as separate arguments or
  a space-separated list, and prints the product. Use fmul() if you need to
  multiply floating-point numbers together.

Examples:

  [mul(6,7)]        => '42'
  [mul(1 2 3 4 5)]  => '120'

See also: add(), div(), mod(), sub()

& div()

div(<integer>, <integer>)

  This function divides two integers and returns the quotient. Both integers
  must be separate arguments to this function. Dividing by zero will return the
  string "inf" for infinity. Use fdiv() if you need to divide two floating-
  point integers.

Examples:

  [div(100,7)]  => '14'
  [div(80,0)]   => 'inf'

See also: add(), mod(), mul(), rdiv(), sub()

& mod()

mod(<integer>, <integer>)

  This function divides two integers and returns the modulus (the remainder).
  Both integers must be separate arguments to this function. If the first
  integer is negative, the resulting remainder will be negative. If the second
  integer is zero, a 0 will be returned.
  
  There is no floating-point version of this function.

Examples:

  [mod(45,3)]   => '0'
  [mod(46,3)]   => '1'
  [mod(47,3)]   => '2'
  [mod(48,3)]   => '0'

  [mod(-47,3)]  => '-2'
  [mod(-47,0)]  => '0'

See also: add(), div(), mul(), rdiv(), sub()

& fadd()

fadd(<real numbers>, ...)

  This function adds up a list of floating-point numbers, either as separate
  arguments or a space-separated list, and prints the sum.

Examples:

  [fadd(3.4 7.6 10.2)]  => '21.2'
  [fadd(pi(),e())]      => '5.859874482'

See also: fdiv(), fmul(), fsub()

& fsub()

fsub(<real number>, <real number>)

  This function subtracts two floating-point numbers and returns the
  difference. Both numbers must be separate arguments to this function.

Examples:

  [fsub(9.43,7.92)]           => '1.51'
  [fsub(fdiv(355,113),pi())]  => '0.000000266'

See also: fadd(), fdiv(), fmul()

& fmul()

fmul(<real numbers>, ...)

  This function multiplies a list of real-numbers, either as separate arguments
  or a space-separated list, and prints the product.

Examples:

  [fmul(3.8 -2.4 10.6)]  => '-96.672'
  [fmul(4,atan(1))]      => '3.141592652'

See also: fadd(), fdiv(), fsub()

& fdiv()

fdiv(<real number>, <real number>)

  This function divides two floating-point numbers and returns the quotient.
  Both numbers must be separate arguments to this function. Dividing by zero
  will return the string "inf" for infinity.

Examples:

  [fdiv(100,7)]  => '14.285714286'
  [fdiv(42,0)]   => 'inf'

See also: fadd(), fmul(), fsub()

& rdiv()

rdiv(<integer>, <integer>)

  This function divides two integers and returns a random result depending on
  the amount left over in the remainder. When the remainder is small compared
  to the divisor, the function will most likely return the integer answer
  as-is. When the remainder is high, the function will more frequently return
  the integer answer + 1. When adding enough rdiv()s in succession, the
  randomness will achieve the same effect as if floating-point division was
  used.

  With a remainder of 0, the function will always return the same result. When
  dividing by zero, a '0' will always be returned. Integers can be positive or
  negative.

Examples:

  [rdiv(5,2)]     => Returns '2' half of the time, otherwise returns '3'.
  [rdiv(99,100)]  => Returns '1' 99% of the time, otherwise '0'.
  [rdiv(18,3)]    => '6'
  [rdiv(20,0)]    => '0'

See also: div(), mod()

& min()

min(<real numbers>, ...)

  This function returns the smallest number (i.e. the minimum) out of a list of
  <real numbers>. The numbers can be specified either as separate arguments or
  as a space-separated list. If no valid numbers are given, it returns 0.

Examples:

  [min(7,4)]           => '4'
  [min(9 4 8 12 2 3)]  => '2'
  [min(7 -2 5 -9 14)]  => '-9'

See also: avg(), max()

& max()

max(<real numbers>, ...)

  This function returns the largest number (i.e. the maximum) out of a list of
  <real numbers>. The numbers can be specified either as separate arguments or
  as a space-separated list. If no valid numbers are given, it returns 0.

Examples:

  [max(7,4)]           => '7'
  [max(9 4 8 12 2 3)]  => '12'
  [max(-2 -7 -4 -9)]   => '-2'

See also: avg(), min()

& avg()

avg(<real numbers>, ...)

  This function finds the average (mean) of a list of <real numbers> by summing
  up the numbers and dividing by the number of values. The numbers can be
  specified either as separate arguments or as a space-separated list. This
  function returns 0 if no valid numbers are given.

Examples:

  [avg(5,12)]      => '8.5'
  [avg(8 15 160)]  => '61'

See also: max(), min(), stddev()

& stddev()

stddev(<real numbers>, ...)

  This function returns the standard deviation of a list of <real numbers>. The
  standard deviation is computed by summing the squares of each value in the
  list subtracted with the list's mean, then dividing the result by the number
  of elements in the list, and then by taking the square-root of that result.
  If all numbers are identical, a 0 is returned.

  For instance, the standard deviation of '4 5 12' is equivalent to:

                  sqrt(((4-7)^2 + (5-7)^2 + (12-7)^2) / 3)

  where 7 is the list's average and 3 is the number of elements in the list.

Examples:

  [stddev(6 9 9 8)]             => '1.224744871'
  [stddev(4 8 1 3 11 5 7 2 4)]  => '2.98142397'
  [stddev(-10.5 10.5)]          => '10.5'
  [stddev(7 7 7)]               => '0'

See also: avg()

& int()

int(<number>)

  This function returns the integer portion of <number>, which can be a whole
  number, floating-point (decimal) number, or a text string that begins with a
  number (and has other characters or symbols). All numbers after the decimal
  point are truncated (not rounded).

Examples:

  [int(3.1419)]       => '3'
  [int(7.82)]         => '7'
  [int(16th Street)]  => '16'

See also: round()

& round()

round(<number>)
round(<number>, <decimal places>)

  Rounds an integer or floating-point number to the nearest integer value, or
  up to 9 <decimal places> if specified. If the number of decimal places
  exceeds the original number, zeroes will be added as placeholders.

Examples:

  [round(3.1419)]     => '3'
  [round(7.82)]       => '8'
  [round(10.309,2)]   => '10.31'
  [round(21.478,5)]   => '21.47800'
  [round(sqrt(2),4)]  => '1.4142'

See also: ceil(), floor(), int()

& ceil()

ceil(<real number>)

  Returns the least integer greater than or equal to <real number>. In other
  words, <real number> is rounded up to the next highest integer.
  
Examples:

  [ceil(4.00)]  => '4'
  [ceil(4.01)]  => '5'

See also: floor(), round()

& floor()

floor(<real number>)

  Returns the greatest integer less than or equal to <real number>. In other
  words, <real number> is rounded down to the next lowest integer.

Examples:

  [floor(4.26)]  => '4'
  [floor(7.99)]  => '7'

See also: ceil(), round()

& neg()

neg(<real number>)

  Returns the negation of <real number>. That is, a positive number becomes
  negative and a negative number becomes positive. The negation of zero is
  always 0.

Examples:

  [neg(42)]     => '-42'
  [neg(-1.78)]  => '1.78'
  [neg(inf)]    => '-inf'

See also: abs(), sign()

& abs()

abs(<real number>)

  Returns the absolute value of <real number>. That is, a negative number
  becomes positive and all other numbers stay the same.

Examples:

  [abs(42)]     => '42'
  [abs(-1.78)]  => '1.78'
  [abs(0)]      => '0'

See also: neg(), sign()

& sign()

sign(<real number>)

  Determines the sign of a <real number>. If positive, this function will
  return 1. If negative, it will return -1. If zero, it will return 0.

Examples:

  [sign(42)]     => '1'
  [sign(-1.78)]  => '-1'
  [sign(0)]      => '0'

See also: abs(), neg()

& sin()

sin(<real number>)

  Returns the sine of <real number>, which is expressed in radians.

Examples:

  [sin(1)]             => '0.841470985'
  [sin(fdiv(pi(),4))]  => '0.707106782'
  [sin(fdiv(pi(),2))]  => '1'

See also: acos(), asin(), atan(), cos(), tan()

& cos()

cos(<real number>)

  Returns the cosine of <real number>, which is expressed in radians.

Examples:

  [cos(1)]     => '0.540302306'
  [cos(pi())]  => '-1'

See also: acos(), asin(), atan(), sin(), tan()

& tan()

tan(<real number>)

  Returns the tangent of <real number>, which is expressed in radians.

Examples:

  [tan(0)]     => '0'
  [tan(1)]     => '1.557407725'
  [tan(pi())]  => '0'

See also: acos(), asin(), atan(), cos(), sin()

& asin()

asin(<real number>)

  Returns the arcsine of <real number>, which is expressed in radians.
  Any number less than -1 or greater than 1 will print "inf" for infinity.

Examples:

  [asin(0)]  => '0'
  [asin(1)]  => '1.570796327'

See also: acos(), atan(), cos(), sin(), tan()

& acos()

acos(<real number>)

  Returns the arccosine of <real number>, which is expressed in radians.
  Any number less than -1 or greater than 1 will print "inf" for infinity.

Examples:

  [acos(0)]  => '1.570796327'
  [acos(1)]  => '3.141592654'

See also: asin(), atan(), cos(), sin(), tan()

& atan()

atan(<real number>)

  Returns the arctangent of <real number>, which is expressed in radians.

Examples:

  [atan(0)]    => '0'
  [atan(1)]    => '0.785398163'
  [atan(inf)]  => '1.570796327'

See also: acos(), asin(), cos(), sin(), tan()

& pi()

pi()

  A mathematical constant that evaluates to approximately "3.141592654".
  PI is the ratio of the circumference of a circle to its diameter.

Example:

  > say A circle whose diameter is 4 has a circumference of [fmul(4,pi())].
  You say, "A circle whose diameter is 4 has a circumference of 12.566370616."

See also: e()

& e()

e()

  A mathematical constant that evaluates to approximately "2.718281828".
  e is an irrational number that denotes the base for all natural logarithms.

Example:

  [ln(e())]  => '1'

See also: pi()

& pow()

pow(<real number>, <exponent>)

  Returns the result of raising <real number> to the power of <exponent>.
  If <real number> is negative and <exponent> is a fraction of a whole number,
  "nan" for not-a-number will be displayed.

Examples:

  [pow(3,4)]     => '81'
  [pow(2,16)]    => '65536'
  [pow(10,6)]    => '1000000'
  [pow(2.5,3)]   => '15.625'
  [pow(9,0.5)]   => '3'
  [pow(-2,3)]    => '-8'
  [pow(-2,4)]    => '16'
  [pow(-2,4.5)]  => 'nan'

See also: exp(), sqrt()

& sqrt()

sqrt(<real number>)

  Returns the square root of <real number>. If <real number> is negative,
  "nan" for not-a-number will be displayed.

Examples:

  [sqrt(0)]         => '0'
  [sqrt(2)]         => '1.414213562'
  [sqrt(pow(8,2))]  => '8'
  [sqrt(-4)]        => 'nan'

See also: pow()

& ln()

ln(<real number>)

  Returns the result of the natural log (base e) of <real number>. If
  <real number> is negative or zero, "nan" for not-a-number will be returned.

  Use log() if you wish to take the log with a base other than e, as rounding
  errors with this function may result.

Examples:

  [ln(1)]       => '0'
  [ln(0)]       => 'nan'
  [ln(exp(4))]  => '4'

See also: exp(), log()

& log()

log(<real number>)
log(<real number>, <base>)

  Returns the logarithm (base 10) of <real number>. If <base> is specified,
  then this returns the log base <base> of <real number>. To take the natural
  log, use e() as the <base> or use the ln() function instead.
  
  If either <real number> or <base> is negative or zero, "nan" for not-a-number
  will be returned.

Examples:

  [log(100)]      => '2'
  [log(1000)]     => '3'
  [log(128,2)]    => '7'
  [log(81,3)]     => '4'
  [log(150,e())]  => '5.010635295'
  [log(2,-4)]     => 'nan'

See also: exp(), ln()

& exp()

exp(<power>)

  Returns the result of raising the numeric constant e to <power>. This is the
  opposite of taking the natural logarithm, ln().

Examples:

  [exp(1)]      => '2.718281828'
  [exp(4)]      => '54.598150033'
  [ln(exp(6))]  => '6'

See also: ln(), log(), pow()

& degrees()

degrees(x, y)

  Returns the angle in degrees from 0 to 359.99 in the direction of [x,y] from
  coordinate [0,0] in a Cartesian graph. Degrees begin in quadrant 1 and
  increase counter-clockwise across the graph. The following diagram describes
  this, with quadrants labelled from I through IV.
  
             90           For example, 0 is directly positive on the X-Axis, 90
             |    45      is directly positive on the Y-Axis, 180 is directly
          II | I.~        negative on the X-Axis, and 270 is directly negative
             |.~          on the Y-Axis.
    180 -----+----- 0
             |            Coordinate [4,4] would be at a 45-degree angle.
         III | IV         Specifying coordinate [0,0] will always return 0.
             |
            270

Examples:

  [degrees(6,6)]    => '45'
  [degrees(2,8)]    => '75.963756532'
  [degrees(8,-4)]   => '333.434948823'
  [degrees(-60,0)]  => '180'

Coordinate System Conversions:

  To convert a pair of points from the Cartesian coordinate system to Polar
  coordinates, you can use dist2d() to find the distance from [0,0] and convert
  the value returned by degrees() into radians. The following two functions
  convert Cartesian points [x,y] to Polar [r,theta]:

    [dist2d(0,0,x,y)] , [fmul(degrees(x,y),fdiv(pi(),180))]

  To convert back from Polar coordinate [r,theta] to Cartesian [x,y], use the
  equation 'r * cos(theta)' to find the x value and 'r * sin(theta)' to find
  the y value:

    [fmul(r,cos(theta))] , [fmul(r,sin(theta))]

See also: dist2d(), dist3d()

& dist2d()

dist2d(x1, y1, x2, y2)

  Returns the distance between points [x1,y1] and [x2,y2] in a two-dimensional
  Cartesian graph. Distance is equal to the square root of the sum (x2-x1)^2 +
  (y2-y1)^2.

Examples:

  [dist2d(0,0,1,1)]  => '1.414213562'
  [dist2d(0,0,3,4)]  => '5'

See also: degrees(), dist3d()

& dist3d()

dist3d(x1, y1, z1, x2, y2, z2)

  Returns the distance between points [x1,y1,z1] and [x2,y2,z2] in a three-
  dimensional Cartesian graph system. Distance is equal to the square root of
  the sum (x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2.

Examples:

  [dist3d(0,0,0,1,1,1)]   => '1.732050808'
  [dist3d(0,0,0,4,8,19)]  => '21'

See also: degrees(), dist2d()

& factor()

factor(<integer>)

  Returns the prime factorization of <integer> as a list of integers that,
  when multiplied together, will result in the original <integer>. The maximum
  valid value for <integer> is 2147483647 (or 2^31 - 1, which is prime).

Examples:

  [factor(15)]    => '3 5'
  [factor(48)]    => '2 2 2 2 3'
  [factor(-154)]  => '-2 7 11'
  [factor(1999)]  => '1999'

& eq()

eq(<number1>, <number2>)

  Logically tests if <number1> is equal to <number2>. Returns 1 if equal, or 0
  if not equal.

Examples:

  [eq(6,82)]     => '0'
  [eq(4.6,4.6)]  => '1'

See also: gt(), gteq(), lt(), lteq(), neq()

& neq()

neq(<number1>, <number2>)

  Logically tests if <number1> is NOT equal to <number2>. Returns 1 if not
  equal, or 0 if equal.

Examples:

  [neq(6,6)]     => '0'
  [neq(40,8.3)]  => '1'

See also: eq(), gt(), gteq(), lt(), lteq()

& gt()

gt(<number1>, <number2>)

  Returns 1 if <number1> is greater than <number2>, 0 otherwise.
  Both numbers can be integers or floating-point.

Examples:

  [gt(7,-4)]  => '1'
  [gt(5,5)]   => '0'

See also: eq(), gteq(), lt(), lteq(), neq()

& gteq()

gteq(<number1>, <number2>)

  Returns 1 if <number1> is greater than or equal to <number2>, 0 otherwise.

Examples:

  [gteq(12,6)]  => '1'
  [gteq(8,8)]   => '1'
  [gteq(4,15)]  => '0'

See also: eq(), gt(), lt(), lteq(), neq()

& lt()

lt(<number1>, <number2>)

  Returns 1 if <number1> is less than <number2>, 0 otherwise.
  Both numbers can be integers or floating-point.

Examples:

  [lt(3,10)]  => '1'
  [lt(5,5)]   => '0'

See also: eq(), gt(), gteq(), lteq(), neq()

& lteq()

lteq(<number1>, <number2>)

  Returns 1 if <number1> is less than or equal to <number2>, 0 otherwise.

Examples:

  [lteq(12,6)]  => '0'
  [lteq(8,8)]   => '1'
  [lteq(4,15)]  => '1'

See also: eq(), gt(), gteq(), lt(), neq()

& ncomp()

ncomp(<number1>, <number2>)

  Compares two decimal numbers, returning 0 if they are equal, -1 if <number1>
  is less than <number2>, or 1 if <number1> is greater than <number2>.

Examples:

  [ncomp(6,10)]        => '-1'
  [ncomp(-0.7,-0.75)]  => '1'
  [ncomp(4,4.0)]       => '0'

See also: between(), comp(), eq(), neq()

& between()

between(<number>, <low>, <high>)

  Returns 1 if <number> is between <low> and <high> inclusive, 0 otherwise.
  This function always returns 0 if <low> is greater than <high>.

Examples:

  [between(10,5,12)]     => '1'
  [between(6,6,20)]      => '1'
  [between(9,9.2,10.6)]  => '0'
  [between(-4,-10,-4)]   => '1'

See also: eq(), ncomp(), neq(), range()

& range()

range(<number>, <low>, <high>)

  Returns <number> if it falls between the range <low> and <high>. Otherwise,
  if <number> is less than <low>, it returns <low>, and if <number> is greater
  than <high>, it returns <high>. All values can be integer or floating-point.

Examples:

  [range(12,15,25)]  => '15'
  [range(22,15,25)]  => '22'
  [range(27,15,25)]  => '25'

Errors:

  "#-1 Invalid range." - The value <low> was specified as greater than <high>.

See also: between()

& if()

if(<expression>, <string>)

  This function evaluates the boolean <expression> for True or False. If True,
  the text <string> will be returned, otherwise a blank string will be printed.

  <expression> is False if it evaluates to "0", "#-1", or the null string "".
  All other values are True.

Examples:

  [if(0,True)]         => ''
  [if(1,True)]         => 'True'
  [if(gt(6,4),True)]   => 'True'
  [if(eq(3,10),True)]  => ''

See also: ifelse(), iftrue(), not(), truth()

& ifelse()

ifelse(<expression>, <true string>, <false string>)

  This function evaluates the boolean <expression> for True or False. If the
  expression is True, <true string> will be returned. Otherwise if the result
  is False, <false string> will be printed. Note that both True and False
  strings are evaluated before checking <expression>.

  <expression> is False if it evaluates to "0", "#-1", or the null string "".
  All other values are True.

Examples:

  [ifelse(1,True,False)]     => 'True'
  [ifelse(0,True,False)]     => 'False'
  [ifelse(test,True,False)]  => 'True'
  [ifelse(,True,False)]      => 'False'
  [ifelse(#42,True,False)]   => 'True'
  [ifelse(#-1,True,False)]   => 'False'

  > say It is [ifelse(timeofday(),sunny,dark)] outside.
  You say, "It is sunny outside."

See also: if(), iftrue(), not(), truth()

& iftrue()

iftrue(<expression>, <false string>)

  This function evaluates <expression> for True or False. If True, then the
  result of <expression> will be displayed, otherwise if False, then the
  <false string> will be printed.

  <expression> is False if it evaluates to "0", "#-1", or the null string "".
  All other values are True.

Examples:

  [iftrue(10,False)]    => '10'
  [iftrue(test,False)]  => 'test'
  [iftrue(#-1,False)]   => 'False'

  > say [setq(2,42)]The answer is [iftrue(v(2),False)]!
  You say, "The answer is 42!"

  > say [setq(2,0)]The answer is [iftrue(v(2),False)]!
  You say, "The answer is False!"

See also: if(), ifelse(), not(), truth()

& truth()

truth(<expression>)

  This function evaluates <expression> and returns 1 if the result is True, or
  0 if it is false. An <expression> is false if it evaluates to "0", "#-1", or
  the empty string "". All other results are considered True.

Examples:

  [truth(6)]    => '1'
  [truth(#-1)]  => '0'

See also: if(), ifelse(), iftrue(), not()

& not()

not(<expression>)

  This function evaluates <expression> and returns the Logical-NOT of the
  result. That is, it returns 1 if the result is False and 0 if True. It is the
  opposite of truth(). An <expression> is False if it evaluates to "0", "#-1",
  or the blank string "".  All other values are considered True.

  It is generally easier to use the NOT symbol '!' in front of a function name
  to do a Logical-NOT. For instance, the following three functions mean the
  same and all return 0: [gteq(3,6)], [not(lt(3,6))], [!lt(3,6)].

Examples:

  [not(6)]        => '0'
  [not(0)]        => '1'
  [not(test)]     => '0'
  [!truth(test)]  => '0'

See also: if(), ifelse(), iftrue(), truth()

& band()

band(<number1>, <number2>)

  Intended for use on a bitfield, this function performs a Binary-AND between
  two numbers and returns the result.

Example:

  > say [band(4781,9817)]
  You say, "521"

  The equation "A AND B" is true only if both A and B have a true value. In the
  above example, the numbers 3144 and 8531 are converted to binary digits. In
  each column, the digits are compared with an AND equation and the result is
  stored in the same column in the answer. If both digits contain a 1, a 1 is
  stored in the answer, otherwise a 0 is stored.
  
  This equation demonstrates the Binary-AND:

        4781 = 01001010101101
    AND 9817 = 10011001011001
    -------------------------
               00001000001001 = 521

Testing Bits:

  This function is most useful for checking if a bit in a given bitfield is
  'on' (set to 1) or 'off' (0). It returns the value that results in a union of
  all 'on' bits in both <number1> and <number2>.
  
  For example, the number 80 is equivalent to the binary number 01010000. The
  bits for "16" and "64" are on (1), but all other bits are off (0). The
  function [band(80,16)] or [band(80,64)] would return True values (16 and 64
  respectively), while [band(80,32)] would return zero, a False value.

See also: base(), bnand(), bor(), bxor()

& bor()

bor(<number1>, <number2>)

  Intended for use on a bitfield, this function performs a Binary-OR between
  two numbers and returns the result.

Example:

  > say [bor(3144,8531)]
  You say, "11611"

  The equation "A OR B" is true when either A or B (or both) has a true value.
  In the above example, the numbers 3144 and 8531 are converted to binary
  digits. In each column, the digits are compared with an OR equation and the
  result is stored in the same column in the answer. If either digit contains a
  1 (or if both digits are 1), a 1 is stored in the answer. A zero is stored
  only if both digits are zero.

  This equation demonstrates the Binary-OR:

       3144 = 00110001001000
    OR 8531 = 10000101010011
    ------------------------
              10110101011011 = 11611

Setting Bits:

  The most common use for this function is to set distinct bits in a number
  without affecting the other bits. In a sense, ORing a number with a single
  bit will turn that bit 'on' (set to 1) regardless of the prior value in that
  bit and independent of the other bits in the number. For example, to turn the
  third and fifth bits on, use the function "[bor(Number, 20)]", where 20 is
  the decimal equivalent of 00010100 in binary.

See also: base(), band(), bnand(), bxor()

& bxor()

bxor(<number1>, <number2>)

  Intended for use on a bitfield, this function performs a Binary-XOR
  (exclusive-OR) between two numbers and returns the result.

Example:

  > say [bxor(2212,1613)]
  You say, "3817"

  The equation "A XOR B" is only true if and only if A or B have a true value
  exclusively. That is, the equation is NOT true if both A and B have equal
  values. In the above example, the numbers 2212 and 1613 are converted to
  binary digits. In each column, the digits are compared using an XOR equation
  and the result is stored in the same column in the answer. If both digits are
  differnt, a 1 is stored in the answer, otherwise a 0 is stored.

  This equation demonstrates the Binary-XOR:

        2212 = 00100010100100
    XOR 1613 = 00011001001101
    -------------------------
               00111011101001 = 3817

Toggling Bits:

  This function is used to toggle bits in a binary number. With <number1>
  corresponding to your original number, the bits set to 1 in <number2> will
  toggle the bit in the same column of <number1>, and bits set to 0 will retain
  the original value in <number1>. For example, to toggle the fourth bit in a
  binary number, use "[bxor(Number, 8)]", where 8 is the decimal equivalent of
  00001000 in binary.

See also: base(), band(), bnand(), bor()

& bnand()

bnand(<number1>, <number2>)

  Intended for use on a bitfield, this function performs a Binary-NAND (Not-And
  or Negated-And) between two numbers are returns the result.

Example:

  > say [bnand(9689,2996)]
  You say, "9289"

  The equation "A NAND B" is only true if A is true and B is false. It is
  equivalent to the equation "A AND (NOT B)". In the above example, the numbers
  9689 and 2996 are converted to binary digits. In each column, the digits are
  compared using a NAND equation and the result is stored in the answer.

  This equation demonstrates the Binary-NAND:

         9689 = 10010111011001
    NAND 2996 = 00101110110100
    --------------------------
                10010001001001 = 9289

Clearing Bits:

  This function is most used to selectively clear the bits in a binary number.
  All the bits in <number2> that are set to 1 will clear the corresponding bit
  in <number1> to 0, regardless of its prior value. Bits in <number2> that are
  zero will have no effect on the bits in <number1>. For example, to unset the
  third bit in a binary number, use "[bnand(Number, 4)]", where 4 is the
  decimal equivlent of 00000100 in binary.

See also: base(), band(), bor(), bxor()

& base()

base(<number>, <original base>, <new base>)

  This function converts a number to a new base. A base is the number of unique
  symbols that can be displayed per digit. For instance, binary digits are
  base-2 because only 0's and 1's can be displayed; decimal numbers are base-10
  because there are 10 digits per number; and so on.

  This function can convert numbers from any two bases between 2 and 36 symbols
  per digit. Bases beyond 10 are treated using letters of the alphabet from A
  to Z to fill in the remaining digits.

Examples:

  [base(85,10,2)]        => '1010101' Converts decimal 85 to binary.
  [base(255,10,8)]       => '377'     Converts decimal 255 to octal (base 8).
  [base(10001111,2,16)]  => '8f'      Converts binary to hexadecimal (base 16).
  [base(10450,6,36)]     => '14u'     Converts a number from base 6 to 36.

Errors:

  "#-1 Bases must be between 2 and 36." - Either <original base> or <new base>
    falls outside of the acceptable range 2 to 36.

  "#-1 Illegal digit." - A digit specified in <number> falls out of the range
    allowed by <original base>.

& land()

land(<expression1>, <expression2>, ...)

  Returns the Logical-AND of <expression1>, <expression2>, and any other
  expressions following. This function returns a 1 if all expressions evaluate
  to be True, and 0 otherwise.
  
  An expression is False if it evaluates to "0", "#-1", or the null string "".
  All other values are True.

Examples:

  [land(-1,#42)]             => '1'
  [land(7,14,0)]             => '0'
  [land(eq(3,3),neq(8,10))]  => '1'
  [land(gt(4,2),lt(8,6))]    => '0'

See also: lor(), lxor()

& lor()

lor(<expression1>, <expression2>, ...)

  Returns the Logical-OR of <expression1>, <expression2>, and any other
  expressions following. This function returns a 1 if any of the expressions
  evaluate to True, and 0 if all of them are False.

  An expression is False if it evaluates to "0", "#-1", or the null string "".
  All other values are True.

Examples:

  [lor(0,1)]        => '1'
  [lor(#5,True,0)]  => '1'
  [lor(0,#-1)]      => '0'

See also: land(), lxor()

& lxor()

lxor(<expression1>, <expression2>)

  Returns the Logical-XOR of <expression1> and <expression2>. This function
  returns a 1 if either <expression1> or <expression2> evaluates to True, but
  not both. In other words, a 1 is returned if the truth value of both
  expressions are different, and a 0 is returned if they are both True or both
  False.

  An expression is False if it evaluates to "0", "#-1", or the null string "".
  All other values are True.

Examples:

  [lxor(0,1)]               => '1'
  [lxor(True,#100)]         => '0'
  [lxor(neq(5,5),not(10))]  => '0'

See also: land(), lor()

& shl()

shl(<number>, <count>)

  This function returns the result of bit-shifting a binary <number> left by
  <count> times. This is equivalent to multiplying <number> by 2 to the <count>
  power, except that it is computationally faster.

Examples:

  [shl(8,1)]    => '16' (00001000 in binary becomes 00010000)
  [shl(9,2)]    => '36' (00001001 in binary becomes 00100100)
  [shl(367,3)]  => '2936' (101101111 in binary becomes 101101111000)

See also: shr()

& shr()

shr(<number>, <count>)

  This function returns the result of bit-shifting a binary <number> right by
  <count> times. This is equivalent to dividing <number> by 2 to the <count>
  power, except that it is computationally faster.

  Note that this is an arithmetic shift and not a logical shift. An arithmetic
  shift preserves the sign-bit of a number, thus doing a "divide" regardless if
  the number was positive or negative.

Examples:

  [shr(16,2)]    => '4' (00010000 in binary becomes 00000100)
  [shr(15,1)]    => '7' (00001111 in binary becomes 00000111)
  [shr(-128,5)]  => '-4' (-128 / 2^5 = -4)

See also: shl()

& ffs()

ffs(<number>)

  This function returns the position of the first bit set in the binary 32-bit
  <number>. The least significant bit is position 1, and the most significant
  is position 32. If no bits are set, a 0 is returned.
  
  Negative numbers are stored in binary on the system as the result of a two's-
  compliment operation on a 32-bit number. For instance, a 4-bit number '0110'
  is considered to have a sign-bit (left-most bit) of 0 and a value of '110',
  or 6. To get -6 by performing two's-compliment, you first invert all the bits
  in the number to make '1001', and then add 1 to the result: '1010' = 6. The
  same procedure can then be repeated to get 6 back from -6.

Examples:

  [ffs(6)]            => '2' (6 is binary 00000110)
  [ffs(32768)]        => '16'
  [ffs(-2147483648)]  => '32' (32-bit number with only the sign bit set)
  [ffs(-2)]           => '2' (All bits set except the least-significant)

See also: bitcount()

& bitcount()

bitcount(<number>)

  Returns the number of bits set to 1 in the binary value <number>. The maximum
  possible value returned is 32, since all values are stored as signed 32-bit
  integers. If no bits are set, a 0 is returned.

Examples:

  [bitcount(6)]    => '2' (6 is binary 00000110)
  [bitcount(-1)]   => '32' (All bits are set in -1)
  [bitcount(255)]  => '8'

See also: ffs()

& inc()

inc(<string>)

  This function increments the rightmost integer portion of <string> by 1. The
  <string> can be a number or word ending in a numeric value. If used on a
  number with a decimal point, the value after the period will be incremented
  and not the entire number itself.

Examples:

  [inc(3)]        => '4'
  [inc(Floor 2)]  => 'Floor 3'
  [inc(6.9)]      => '6.10'
  [inc(Room-7)]   => 'Room-6' (The integer here is -7 and not 7)

Errors:

  "#-1 String must end in an integer." - The string does not end with a digit.

See also: dec()

& dec()

dec(<string>)

  This function decrements the rightmost integer portion of <string> by 1. The
  <string> can be a number or word ending in a numeric value. If used on a
  number with a decimal point, the value after the period will be decremented
  and not the entire number itself.

Examples:

  [dec(6)]               => '5'
  [dec(B4)]              => 'B3'
  [dec(Version 1.8.10)]  => 'Version 1.8.9'
  [dec(3-8-78)]          => '3-8-79'

Errors:

  "#-1 String must end in an integer." - The string does not end with a digit.

See also: inc()

& mudname()

mudname()

  Returns the full name of the Multi-User Dungeon (MUD) as configured by the
  game's administrator. This is usually the name that appears in various mud
  lists and is the name that the mud is listed under in reports from RWHO
  servers.

& version()

version()

  Returns the revision number of the program base the MUD is currently running
  under. Later (higher) version numbers can have more features implemented and
  have more problems with the game server fixed than earlier or prior versions.

& config()

config(<variable>)

Powers: Security

  Returns the value stored in the specified system configuration variable. Note
  that some configuration options are accessible only by Wizards and cannot be
  obtained by other players. All configuration variables can be viewed by using
  the command '@list config'.

Examples:

  [config(room_cost)]       => '10'
  [config(restrict_build)]  => '0'

Errors:

  "#-1 No such config variable." - The specified <variable> does not exist.
  "#-1 Permission denied." - Access to the specified <variable> is restricted.

See also: @config, System Configuration

& uptime()

uptime()

  Returns the number of seconds elapsed since the game server had initially
  started. Note that this is not necessarily the same as the time since the
  last reboot.

See also: +uptime

& restarts()

restarts()

  Returns the number of times the game server has been restarted while keeping
  its players actively online. This will return 0 the first time the game is
  turned on, with the number incrementing by 1 each time a @reboot is issued.

  This function is useful for coding @startup scripts that can behave
  differently depending on if the MARE is starting fresh with no players logged
  in or if the game had just come out of a @reboot.

See also: @reboot, @startup

& netstat()

netstat(<variable>)

  Returns the value stored in the specified network statistics variable. These
  statistics describe total values accumulated since the initial start time of
  the MARE and not necessarily since the last reboot. They are normally seen
  via the +info command.

Server Variables:

  "FILES" - File descriptors currently opened by the game server.
  "OUTPUT" - Output bytes sent to all players over the network.
  "INPUT" - Input bytes received by all players over the network.
  "EXEC" - Times the game server has been started or rebooted.
  "CRASHES" - Number of Segmentation Faults or infinite loops detected.
  "DBSAVE" - Number of times the database was saved.
  "LOGINS" - Connections made to the game server across all ports.
  "CONNECTS" - Successful connects to player accounts.
  "FAILED" - Failed connects to player accounts (bad password, etc).
  "NEWCR" - New characters created on the game.
  "GUESTS" - Guest character logins on the game.
  "NCMDS" - Total number of player and object commands executed.
  "NPCMDS" - Player commands typed in directly from the network.
  "NQCMDS" - Queued commands sent from both objects and players.
  "NFCMDS" - Failed (unrecognizable) commands by players and objects.
  "QUEUE" - Calls to the command-queue processing routine.
  "OVERRUNS" - Number of times the queue could not be emptied within 100 ms.
  "MAIL" - Number of +mail messages delivered to all players.
  "EMAIL" - Emails sent via +mail to destinations on the internet.
  "ERECV" - Incoming emails received from senders on the internet.
  "QUERY" - Number of Hostname Lookup queries sent to a Domain Name Server.
  "RESOLV" - Number of Domain Name Server queries successfully resolved.

Combat Variables:

  The following variables are only available if Combat support is compiled
  into the game server:

  "ATKS" - Total number of combat techniques executed.
  "GOLD" - Total amount of Gold brought into the game via defeating monsters.
  "TCHEST" - Total number of Treasure Chests obtained via defeating monsters.
  "EXP" - Total number of Experience Points obtained by all players' kills.
  "LEVEL" - Total number of player "Levelups" achieved.
  "TECHPTS" - Total number of Technique Points obtained by all players' kills.
  "DMONSTER" - Total number of monsters defeated.
  "DPLAYER" - Total number of players defeated.
  "ALMANAC" - Weather almanac system updates.
  "CASTROD" - Number of fishing rods cast.
  "FISH" - Number of fish caught.
  "PLANTS" - Number of plants picked in the wilderness.
  "MINERALS" - Number of minerals mined in the caves and mountains.

See also: +info

& dbtop()

dbtop()

  This function returns the reference number of the highest object number
  created in the database. This is equal to the number of objects in the
  database minus 1.

& upfront()

upfront()

  This function returns the database reference number that the next object
  created will use. Objects can be created and destroyed by several commands,
  each which can change the output of this value.
  
Warning:

  Because of queue delays and other players online, objects should not use
  [upfront()] to determine the number of a new object before it is created.
  Use container-dependent functions, such as [con()], after the object is
  created instead.

& cpu()

cpu()

  This function displays the current CPU Usage that the game server is using on
  the host system. The usage is expressed as a percentage that is updated every
  60 seconds. A 100.00 means that the game is constantly using CPU time and
  that no other process on the system is active. A 0.00 means that the game is
  idle and no player or object is using any commands.
  
  System administrators should monitor this value to make sure it stays under a
  resonable percentage of CPU Time used. High values (greater than 60.0%) can
  be an indication of runaway objects executing attributes in an infinite loop.
  This value reads 0 for one minute after the game is restarted.

See also: cputime()

& cputime()

cputime()

  This function returns the total number of seconds of CPU Usage since the game
  was started. The value carries over during @reboots, but begins at 0 after a
  @shutdown. It is possible that on different systems with CPUs of varying
  speeds, the same game can take up more CPU time on slower computers than on
  faster ones.

See also: cpu()

& wtime()

wtime()
wtime(<seconds>)

  :)

See also: date(), time(), wdate()

Set 4: Weather AlmanacÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  wtime()      ³  moonphase()  ³  weather()
  wdate()      ³  dayofyear()  ³
  timeofday()  ³  season()     ³

& time()

time()
time(<time string>)

  Returns an alphanumerical string representative of the current date and time
  in the format "Wkd Mth DD HH:MM:SS Year". The actual time displayed is
  dependent on your Timezone settings, which can be changed using the "+tzone"
  command.

Example:

  > say [time()]
  You say, "Mon May  7 16:10:31 2001"

Time Strings:

  As with many time functions, an optional <time string> can be used as an
  argument. Specifying a string changes the output of the function to the time
  you specify instead of the current system time. Possible time strings include
  the following:

  "Month Day HH:MM:SS Year" - The default time string which is printed by the
    [time()] function. The day of the week can be omitted. If using a 12-hour
    time, you can use the keywords "A.M." or "P.M." to specify which half of
    the day you are referring to.

  "5 minutes 45 seconds" - An English time string that represents time relative
    to the current system time. To specify time in the past rather than the
    future, you can either use negative numbers or the special keyword "ago" at
    the end of the string. Other time-related keywords include "last", "this",
    "next", and the ordinals "first" through "twelfth". Optional keywords "now"
    or "today" refers to the current time, or "yesterday" and "tomorrow" to
    change only the Day field.

  "5/7/2001 4:10 pm" - An example of mixing date and time formats to refer to a
    specific point in time. Month, Day, and Year can be separated by /, -, or
    . symbols and is expected to be in either the MM-DD-YY, MM-DD-YYYY, or
    YYYY-MM-DD formats. If the hours, minutes, and seconds are omitted, those
    fields are assumed to be 00. If the year is omitted, the function assumes
    you want the current year.

  "989266231" - A single number denotes Absolute Time in seconds since the
    Epoch, which started in January 1st, 1970. This is the same value that the
    [xtime()] function displays given a time string. Seconds are expressed in
    Universal Time Coordinated (UTC) and can differ depending on your current
    Timezone setting (see 'help +tzone').

Errors:

  "#-1 Invalid Date." - The <time string> specified was unable to be parsed.

See also: date(), rtime(), xtime()

& date()

date()
date(<time string>)

  Returns a string containing the current date in the format "Weekday, Month
  Day, Year". The actual day displayed is dependent on your Timezone settings,
  which can be changed using the "+tzone" command.

  An optional <time string> can be specified to return the date of a specific
  point in time. See 'help time()' for more information on specifying time
  strings.

Example:

  > say [date()]
  You say, "Monday, May 7, 2001"

Errors:

  "#-1 Invalid Date." - The <time string> specified was unable to be parsed.

See also: rtime(), time(), xtime()

& rtime()

rtime()
rtime(<time string>)

  Returns a string containing the current 12-hour time in the format
  "HH:MM:SS AM/PM". The actual time displayed is dependent on your Timezone
  settings, which can be changed using the "+tzone" command.

  An optional <time string> can be specified to return a specific point in
  time. See 'help time()' for more information on specifying time strings.

Example:

  > say [rtime()]
  You say, "04:10:31 PM"

Errors:

  "#-1 Invalid Date." - The <time string> specified was unable to be parsed.

See also: date(), time(), xtime()

& xtime()

xtime()
xtime(<time string>)

  Returns the number of elapsed seconds since the Epoch, which occurred on the
  midnight of January 1, 1970. This is often referred to as Absolute Time and
  can be used to time intervals for use with the @wait command. The time
  returned is independent of the user's Timezone setting and is expressed as a
  decimal number with microsecond precision for the purposes of timing short
  delays.

  An optional <time string> can be specified to return a specific point in
  time. See 'help time()' for more information on specifying time strings.

Example:

  > say [xtime()]
  You say, "989266231.183759"
  > [wait a few seconds...]
  > say [xtime()]
  You say, "989266237.967396"

Errors:

  "#-1 Invalid Date." - The <time string> specified was unable to be parsed.

See also: date(), rtime(), time()

& tml()

tml(<seconds>)

  Returns a string displaying the number of <seconds> in the long form as shown
  in the Online column on the 'who' list, such as "HH:MM" or "DDd HH:MM".
  "00:00" will be displayed if <seconds> is negative. Any time value greater
  than 999 days cannot be fully represented using this format.

Examples:

  [tml(13200)]    => '03:40'
  [tml(2628300)]  => '30d 10:05'

See also: tma(), tmf(), tms()

& tms()

tms(<seconds>)

  Returns a string displaying the number of <seconds> in the short form as
  shown in the Idle column on the 'who' list, such as "4s" or "13m". "0s" will
  be diplayed if <seconds> is negative. The symbols used in order stand for
  Seconds, Minutes, Hours, Days, Weeks, and Years.

Examples:

  [tms(42)]         => '42s'
  [tms(355)]        => '5m'
  [tms(2420000)]    => '4w'
  [tms(989266231)]  => '31y'

See also: tma(), tmf(), tml()

& tmf()

tmf(<seconds>)

  Returns a string displaying the number of <seconds> in the full human-
  readable form, such as "39 minutes", "an hour", or "2 days". "0 seconds" will
  be displayed if <seconds> is negative.

Examples:

  [tmf(38)]       => '38 seconds'
  [tmf(680)]      => '11 minutes'
  [tmf(1209600)]  => '2 weeks'

See also: tma(), tml(), tms()

& tma()

tma(<seconds>)

  Returns a string displaying the number of <seconds> showing all the elements
  of time in a short format separated by commas. "0s" will be displayed if
  <seconds> is negative.

Examples:

  [tma(20)]       => '20s'
  [tma(100)]      => '1m, 40s'
  [tma(2358911)]  => '27d, 7h, 15m, 11s'

See also: tmf(), tml(), tms()

& idle()

idle(<player>)

Powers: Who

  Returns the number of seconds a connected player has been Idle, as seen on
  the 'who' list.

Examples:

  [idle(me)]      => '0'
  [idle(*Macro)]  => '1907468'
  [idle(#1)]      => '#-1 Not connected.'

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The <player> is hidden and may/may not be online.
  "#-1 Not connected." - The <player> is not hidden and currently offline.

See also: who, lwho(), onfor()

& onfor()

onfor(<player>)

Powers: Who

  Returns the number of seconds a player has been logged into the game since
  the time he or she had typed in the correct password. This is the same value
  displayed in the Online column of the 'who' list.

Example:

  > say [onfor(me)]
  You say, "1468"

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The <player> is hidden and may/may not be online.
  "#-1 Not connected." - The <player> is not hidden and currently offline.

See also: who, idle(), lwho()

& lwho()

lwho()

  Returns a space-separated list of all player database numbers currently
  connected to the game and not hidden from you.

See also: who, cwho(), idle(), onfor()

& cwho()

cwho(<channel>)

  Returns a space-separated list of all players online currently listening to
  the +com <channel>. Only players visible on the 'who' list are reported.

Errors:

  "#-1 Not on channel." - The invoker (owner) must be listening on <channel>.

See also: who, lwho()

& laston()

laston(<player>)

  Returns the time in seconds since the Epoch (January 1, 1970) of the last
  time <player> has logged onto the game. It is allowable to retrieve
  [laston()] values for hidden players.
  
  Note that this is different from the duration [onfor()] gives, such that
  [laston()] is set the moment <player> sees the logon room, and [onfor()] is
  set the moment <player> types in the correct password.

Errors:

  "#-1 No such player." - The argument specified does not match a player.

See also: onfor(), lastoff()

& lastoff()

lastoff(<player>)

Powers: Who

  Returns the time in seconds since the Epoch (January 1, 1970) of the last
  time <player> has logged off of the game. If <player> is currently online,
  this value refers to the player's previous session (or 0 if the player had
  never logged on). You cannot view the [lastoff()] value for hidden players
  without the Who power.

Errors:

  "#-1 No such player." - The argument specified does not match a player.

  "#-1 Permission denied." - The <player> is currently hidden and the user does
    not have the Who power.

See also: laston()

& sessions()

sessions(<player>)

Powers: Functions

  Returns the number of times <player> has connected to the game since his or
  her character was initially created. When used on Guest characters, this
  function will always return 1.

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The user does not have the Functions power.

See also: age(), steps()

& steps()

steps(<player>)

Powers: Functions

  Returns the number of steps through exits or moves via @teleport a <player>
  has taken since his or her character was initially created.

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The user does not have the Functions power.

See also: age(), sessions()

& age()

age(<player>)

Powers: Functions

  Returns the total age of a <player> in seconds. A player's age is his or her
  total time spent logged into the game since the character was initially
  created.

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The user does not have the Functions power.

See also: age(), sessions()

& gender()

gender(<object>)

  Returns a string describing the gender of <object>, which must be either an
  object or player in the room or being held by the user. This function has
  four possible outputs: Male, Female, Neuter, and Plural, however only Male
  and Female are valid outputs when used on Player objects.

  The gender of a non-player object is derived from the first letter of the
  object's @sex attribute, which is commonly used for gender-specific pronouns.
  "Neuter" describes objects with a default or unset gender whose pronouns
  are mentioned as 'it' and 'its'. "Plural" describes objects such as 'Bowling
  Balls' or 'Fishermen' whose pronouns are mentioned as 'they' and 'their'.
  See 'help Gender' for more details on gender classification.

Errors:

  "#-1 Too far away to see." - The <object> isn't in your immediate vicinity.

See also: @sex, Gender

& cols()

cols(<object>)

  This function returns the number of columns on the screen of the owner of
  <object>. It can be used without restriction, although the returned value can
  change during the time the owner connects and disconnects, or if the owner
  changes the window size on his or her terminal client program.

  The default number of columns for new characters is 80.

See also: rows(), term()

& rows()

rows(<object>)

  This function returns the number of rows on the screen of the owner of
  <object>. It can be used without restriction, although the returned value can
  change during the time the owner connects and disconnets, or if the owner
  changes the window size on his or her terminal client program.

  The default number of rows for new characters is 24.

See also: cols(), term()

& term()

term(<player>, <variable>)

  This function returns the value of a <player>'s specific +term or +config
  setting. Objects can use this function to determine the player's terminal
  capabilities and react accordingly to his or her chosen settings.

  For variables "Rows" and "Columns", this function will return the current
  value stored in the player's session. For all other variables, this function
  will return 1 if the setting is enabled, and 0 if disabled.

  The following +term variables are recognized:

  "Rows" - The number of rows on the player's screen.
  "Columns" - The number of columns on the player's screen.
  "Ansi" - The player's terminal supports ANSI escape codes.
  "Highfont" - The player is using the standard VGA 256-character font.
  "Graphics" - The player is using a specialized font designed for the game.
  "Wordwrap" - The player has automatic word-wrapping turned on.
  "Beeps" - The player hears an alert bell when emitting a %G pronoun.
  "Music" - The player has background music and sound effects turned on.
  "Icons" - The player has full-color icon support turned on.

  The following +config variables are recognized:

  "Reginfo" - The player's registration information is visible on '+finger'.
  "Pager" - The player has a -More- prompt enabled when viewing helptext.
  "Safe" - The player has the safe @destroy option turned on.

Examples:

  [term(me, Columns)]  => '80'
  [term(#1, Reginfo)]  => '0'

Errors:

  "#-1 No such term setting." - The specified <variable> does not exist.

See also: +term, cols(), rows()

& input()

input(<player>)

Powers: Who

  Returns the total number of bytes <player> has inputted into the game server
  via the network connection during the current session. You need the Who power
  to see the statistics of other players online.

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The user does not have the Who power.
  "#-1 Not connected." - The <player> is not hidden and currently offline.

See also: cmds(), output()

& output()

output(<player>)

Powers: Who

  Returns the total number of bytes outputted from the game server to <player>
  via the network connection during the current session. You need the Who power
  to see the statistics of other players online.

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The user does not have the Who power.
  "#-1 Not connected." - The <player> is not hidden and currently offline.

See also: cmds(), input()

& cmds()

cmds(<player>)

Powers: Who

  Returns the total number of commands executed by <player> in direct mode;
  that is, the number of command lines typed in over the network and not
  triggered using the Command Queue. You need the Who power to see the
  statistics of other players online.

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The user does not have the Who power.
  "#-1 Not connected." - The <player> is not hidden and currently offline.

See also: input(), output()

& host()

host(<player>)

Powers: Who

  Returns the origin Hostname of <player>'s internet connection. You need the
  Who power to see hostnames of users other than yourself.

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The user does not have the Who power.
  "#-1 Not connected." - The <player> is not hidden and currently offline.

See also: concid(), port()

& port()

port(<player>)

Powers: Who

  Returns the origin Port of <player>'s internet connection on the remote host
  machine. You need the Who power to see ports of users other than yourself.

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The user does not have the Who power.
  "#-1 Not connected." - The <player> is not hidden and currently offline.

See also: concid(), host()

& concid()

concid(<player>)

Powers: Who

  Returns the Connection-ID number of <player>'s current session on the game
  server. Each connection made to the server is given a unique ID to identify
  that connection both before and after the player logs in. Connection-IDs are
  also used to track services and open sockets that have no player character
  associated with them. You need the Who power to see the Connection-IDs of
  other players.

Errors:

  "#-1 No such player." - The argument specified does not match a player.
  "#-1 Permission denied." - The user does not have the Who power.
  "#-1 Not connected." - The <player> is not hidden and currently offline.

See also: @ctrace, host(), port()

& num()

num(<object>)

  Returns the database reference number of <object>, or "#-1" if the game
  cannot find the specified object from your location. If two objects in a room
  have the same name, only the number of the first match will be returned.
  
  <object> can be the name of an object in the room's contents, an object in
  the user's inventory, an exit name, the keyword "here" to classify the room
  itself, or the keyword "me" to classify the person or thing using the
  function. You can also specify a player's name or alias by prefixing <object>
  with a '*' symbol. See the topic 'help Matching' for more details.

Examples:

  [num(here)]       => '#2000'
  [num(me)]         => '#18639'
  [num(*God)]       => '#1'
  [num(Books)]      => '#662'
  [num(gibberish)]  => '#-1' (Object was not found anywhere)

See also: flags(), name(), pnum(), unparse(), Matching

& pnum()

pnum(<playername>)

  Like the [num()] function, this function also returns the refernce number of
  an object, but it can only be used to match the names of player characters in
  the database. <playername> can refer to either a player's full name or one's
  @alias and does not require a leading '*' symbol. If <playername> does not
  exist or is not a player, a "#-1" will be returned.
  
  Note: The keyword 'me' cannot be used to reference the function user.

Examples:

  [pnum(God)]   => '#1'
  [pnum(*God)]  => '#1'
  [pnum(me)]    => '#-1'

See also: name(), num()

& name()

name(<object>)

  Returns the name of <object> in the database, or a null string if the game
  cannot find a valid match for <object>.

  <object> can be the name of an object in the room's contents, an object in
  the user's inventory, an exit name, the keyword "here" to classify the room
  itself, or the keyword "me" to classify the person or thing using the
  function. You can also specify a player's name or alias by prefixing <object>
  with a '*' symbol. See the topic 'help Matching' for more details.

Examples:

  [name(#0)]    => 'Limbo'
  [name(east)]  => 'East <E>'
  [name(here)]  => 'Programmer's Nexus'
  [name(me)]    => 'Wizard'

See also: flags(), fullname(), num(), unparse(), Matching

& cname()

cname(<object>)

  Returns the colored name of <object> in the database, or a null string if the
  game cannot find a valid match for <object>. The colored name of an object is
  based on that object's @cname attribute, or the object's @color if @cname is
  not set.

Examples:

  [cname(*g)]  => '[1;36mG[;36ma[1;34mn[;34md[1ma[;36ml[1mf[32m'

See also: @cname, @color, fullname(), name(), unparse()

& fullname()

fullname(<object>)

  Like [name()], this function returns the name of <object> as stored in the
  database, except that any aliases listed on <object>'s @alias attribute will
  be appended with semicolon separators.

Examples:

  [fullname(#0)]    => 'Limbo'
  [fullname(east)]  => 'East <E>;east;e'

See also: @alias, name(), num()

& flags()

flags(<object>)

  This function returns a string consising of the letters of flags set on
  <object>, just as they would be seen after <object>'s reference number during
  an 'examine'. Each case-sensitive letter corresponds to a flag shown in the
  '@list flags' table. Not all object types can have all flags set, and a null
  string can be returned for an object without any flags set.

  You can use the [hasflag()] function to determine if a specific flag is set
  on an object. Without the Who power, the Connected flag 'c' will not appear
  for hidden players, even if you can see them in the room.

Examples:

  [flags(#0)]  => 'RDJL'
  [flags(me)]  => 'Pc'

See also: hasflag(), name(), num(), unparse(), Flags

& unparse()

unparse(<object>)

  Displays the name, reference number, and flags of <object> in parentheses
  just as they would be seen during an 'examine' of the object. The string
  displayed contains the same coloring codes as used on the 'examine' screen,
  even if the player using this function has ANSI Terminal capabilities turned
  off. You can use the [strip()] function to remove the color from the result.
  
  The <object> argument can also take special reference numbers that various
  database functions will output. These negative numbers begin with a '#'
  symbol and are listed below:

  "#-1" - "*NOTHING*". This object does not exist in the database.
  "#-2" - "*AMBIGUOUS*". The game server is unclear which object is referenced.
  "#-3" - "*HOME*". An exit whose link points to the home of those using it.

  Any others are returned as "*UNDEFINED*".

Examples:

  [unparse(#0)]   => '[0;37mLimbo[1m(#0RDJL)[32m'
  [unparse(me)]   => '[0;36mWizard[1m(#2Pc)[32m'
  [unparse(#-1)]  => '*NOTHING*'

  Here is an example of creating an exit that points home:

  > @open Return
  Return opened.
  > @link Return=home
  Return linked to *HOME*.
  > say [link(Return)] = [unparse(link(Return))]
  You say, "#-3 = *HOME*"

See also: examine, flags(), name(), num(), strip()

& loc()

loc(<object>)

Powers: Functions

  Returns the database reference number of the location of <object>. To view
  the location of an object owned by someone else, it either must be in a room
  that you control with the Functions power or be an object that you can see
  from your present location.
  
  The location of a room or zone is the object itself, and the location of an
  exit is the room of its source.

  Players not set Dark can be located as long as they are in a room set with a
  Jump_Ok, Link_Ok, Abode, or Visible flag. Zones not set Universal can locate
  any object in any room belonging to the zone.

Examples:

  [loc(me)]   => '#42'
  [loc(#42)]  => '#42'

Errors:

  "#-1 Too far away to see." - The <object> isn't in your immediate vicinity.

See also: rloc(), room()

& rloc()

rloc(<object>, <levels>)

Powers: Functions

  This function can be used to recursively get <object>'s location up to 100
  levels of recursion. The <levels> parameter indicates the number of nested
  [loc()] calls to make on <object>, except that this function allows you to
  take the location of objects that would previously fail if you can not
  control <object>'s location. For example, [loc(loc(<object>))] could be
  replaced with [rloc(<object>,2)].

  [rloc(<object>,0)] is the same as [num(<object>)], and [rloc(<object>,1)] is
  the same as [loc(<object>)].

Example:

  > say [num(me)] = [type(me)]
  You say, "#100 = Player"
  > say [loc(me)] = [type(loc(me))]
  You say, "#188 = Thing"
  > say [loc(loc(me))] = [type(loc(loc(me)))]
  You say, "#186 = Room"
  > @foreach 0 1 2 3=say [rloc(me,v(0))]
  You say, "#100 #188 #186 #186"

Errors:

  "#-1 Too far away to see." - The <object> isn't in your immediate vicinity.

See also: loc(), room()

& room()

room(<object>)

  This function recursively traces back the location of <object>, returning the
  main room in which <object> is physically residing. It is equivalent to
  calling [loc()] on <object> repeatedly until it reaches a room and returns
  its database reference number. This same room determines the zones that
  listen for softcode commands typed in or executed by <object>.

  If an object's location chain cannot be traced back to a room, because the
  object is either inside itself or other objects inside themselves, this
  function will return "#-1". This function will always return "#-1" when used
  on Zone objects.

Errors:

  "#-1 Too far away to see." - The <object> isn't in your immediate vicinity.

See also: loc(), rloc()

& valid()

valid(<category>, <name>)

  This function checks to see if <name> is a valid database name for use in
  <category>, returning 1 if successful or 0 if <name> cannot be used. Category
  names can be abbreviated.

  The following categories are recognized:

  "Name" - Tests for a valid object name. Valid names must not begin with one
           of the symbols *#!._$ or a space or single quote. Names cannot
           contain one of the symbols =&|@; anywhere inside. Names also cannot
           be one of "me", "home", "here", or "quit", and they cannot be more
           than 50 characters long.

  "Playername" - Tests for a valid playername that can be set with @name. Names
                 must be between 3 and 16 chracters long, cannot begin with a
                 digit, and cannot start with the Guest character prefix or the
                 name of the MARE. Playernames can contain a period, dash, or
                 single-quote, but no other symbols. This function also returns
                 0 if the name is already taken by yourself or another player
                 on the game.

  "Alias" - Tests for a valid player alias that can be set using @alias.
            Restrictions are similar to "Playername" above, except that aliases
            can be any length and can begin with a digit.

  "Attribute" - Tests for a valid attribute name for use with @defattr. Names
                may be single words up to 64 characters and contain any digit,
                letter or the symbols !#$%&*+,-./_ and single or double quotes.

  "Itemname" - Tests for a valid name for a softcoded item or proper noun. Item
               names can be 64 character long and can only contain letters,
               digits, spaces, the symbols !-.? and single-quotes.

Examples:

  [valid(name, Recreation Room)]  => '1'
  [valid(playername, Guest42)]    => '0'
  [valid(attribute, c16+)]        => '1'

Errors:

  "#-1 No such category." - <category> is not one of the above categories.

See also: @name, @defattr

& link()

Powers: Functions

  This function can 

  Note: link() can return #-1 and #-3 sometimes...

Set 6: Object Matching FunctionsÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  num()       name()      loc()     ³  con()       exit()      linkup()
  pnum()      fullname()  link()    ³  lcon()      lexits()    entrances()
  flags()     rmatch()    owner()   ³  plcon()     oexit()     inzone()
  unparse()               next()    ³  objlist()   randexit()  zwho()
                                    ³
  type()      room()      relay()   ³  powers()    parents()   subj()
  class()     rloc()      zone()    ³  controls()  children()  objn()
  rank()      nearby()    plane()   ³  haspow()    is_a()      poss()
  immortal()  sees()                ³  hasflag()   has_a()     aposs()

num
pnum
flags
unparse

name
fullname

loc
rloc
room
nearby
sees

link
linkup
entrances

zone
inzone
zwho

& strlen()

strlen(<string>)

  This function returns the number of characters in <string>.

Examples:

  [strlen(This is a test)]  => '14'
  [strlen({Would you like coffee, or perhaps tea?})]  => '38'
  [strlen({})]  => '0'

See also: wcount()

& wcount()

wcount(<word list>)
wcount(<word list>, <delimiter>)

  This function returns the number of words in <word list>. An optional
  <delimiter> character can be used to separate words. By default, any number
  of spaces will separate words.

Examples:

  [wcount(Alpha Beta Gamma)]                  => '3'
  [wcount(This:is:a:colon:separated:list,:)]  => '6'

See also: strlen()

& strcat()

strcat(<string1>, <string2>, ..., <stringN>)

  This function concatenates two or more strings together, returning the final
  result. The strings are appended in order without any spaces or delimiters
  between them.
  
  There is no limit to the number of arguments or size of strings, except for
  the number of characters that can fit on a line, 8000.

Examples:

  [strcat(foo,bar)]             => 'foobar'
  [strcat(word1,spc(1),word2)]  => 'word1 word2'

& capstr()

capstr(<string>)

  This function returns <string> with the first letter capitalized. If the
  first character is not a letter or is already capitalized, then the string
  returned is unchanged.

Examples:

  [capstr(the winding path)]  => 'The winding path'
  [capstr(Oak Grove)]         => 'Oak Grove'

See also: lcstr(), ucstr()

& lcstr()

lcstr(<string>)

  This function returns <string> with all letters converted to lowercase.
  Anything that is not a letter is unaffected.

Example:

  [lcstr(WiCkEd CoOl)]  => 'wicked cool'

See also: capstr(), ucstr()

& ucstr()

ucstr(<string>)

  This function returns <string> with all letters converted to uppercase.
  Anything that is not a letter is unaffected.

Example:

  [ucstr(Let there be light!)]  => 'LET THERE BE LIGHT!'

See also: capstr(), lcstr()

& match()

match(<string>, <pattern>)

  This function compares <string> with <pattern>, returning 1 if there is a
  match or 0 if no match exists. The <pattern> may contain '*' and '?'
  wildcards, as well as begin with boolean characters '!', '<', or '>'.
  The <pattern> is not case-sensitive.
  
  The wildcard '?' matches only one character, and the wildcard '*' matches
  zero or more characters. For example, 's?x' would match 'sex' or 'six' and
  not 'socx', but 's*x' would match any of them.

Examples:

  [match(This is a test,This is a test)]  => '1' (Perfect match)
  [match(This is a test,*t*)]             => '1' (String contains a 't')
  [match(This is a test,test)]            => '0' (Both strings do not match)
  [match(Radix,r*x)]                      => '1' (Matches anything between r-x)
  [match(Radix,r?x)]                      => '0' (More than 1 letter in r-x)
  [match(622,>8)]                         => '1' (622 is greater than 8)
  [match(d,>a)]                           => '1' ('d' comes after 'a')
  [match(a,!b)]                           => '1' ('a' does not match 'b')

See also: matchall(), regmatch(), wmatch()

& wmatch()

wmatch(<word list>, <pattern>)
wmatch(<word list>, <pattern>, <delimiter>)

  This function returns the number of the first word in <word list> that
  matches <pattern>, according to the rules mentioned in 'help match()'. The
  <pattern> may contain wildcards and begin with boolean characters. Words are
  numbered starting from 1. If no match is found for any word in <word list>,
  0 is returned.

  An optional delimiter character can be used to separate words. By default,
  any number of spaces will separate words.

Examples:

  [wmatch(This is a test,test)]  => '4' (Only the 4th word matches)
  [wmatch(This is a test,is)]    => '2' (Second word)
  [wmatch(This is a test,*is*)]  => '1' ('This' contains 'is')
  [wmatch(This is a test,!t*)]   => '2' (2nd word has the first match)
  [wmatch(5 10 20 40,>15)]       => '3' (3rd word has the first match)

  [wmatch(This is a test,is a)]  => '0' ('is a' does not match a single word)
  [wmatch(This-is-a-test,is,-)]  => '2' (Second word, delimited by '-')

See also: match(), matchall()

& matchall()

matchall(<word list>, <pattern>)
matchall(<word list>, <pattern>, <delimiter>)

  This function behaves exactly like wmatch(), except that it returns a list of
  numbers for each word in <word list> that successfully matches <pattern>. The
  <pattern> may contain wildcards and begin with boolean characters. Words are
  numbered starting from 1. If no match is found for any word in <word list>, a
  blank string is returned.

  An optional delimiter character can be used to separate words. By default,
  any number of spaces will separate words.

Examples:

  [matchall(This is a test,*is*)]              => '1 2'
  [matchall(This is a test,dog)]               => ''
  [matchall(apples|bananas|oranges,!*a*e*,|)]  => '2'
  [matchall(5 10 20 40,>15)]                   => '3 4'

See also: match(), wmatch()

& regmatch()

regmatch(<string>, <pattern>)
regmatch(<string>, <pattern>, <register>)

  This function performs regular expression matching with <pattern> on
  <string>, returning 1 if there is a match or 0 if no match exists. The
  <pattern> may contain wildcards '*' and '?', but it must not begin with any
  boolean characters. The <pattern> is not case-sensitive.

  This function has the side-effect of modifying the environment variables %0
  through %9 with the text substituted by each wildcard in <pattern>. That is,
  the text matching the first '*' or '?' becomes %0, the second becomes %1, and
  so on up through %9. Wildcards beyond %9 are not recorded but still determine
  whether a successful match takes place.

  An optional <register> number from 0 to 9 can be specified. This determines
  the first environment variable to which the parser will begin recording
  matches.

  If only the side-effect of the function is wanted, you can use [mid(x,0,0)]
  or [left(x,0)] to nullify the result.

Examples:

  > say Match=[regmatch(@set me=Dark,@set *=*)], env0=%0, env1=%1
  You say, "Match=1, env0=me, env1=Dark"
  > say Match=[regmatch(Does not match,*k*)], env0=%0, env1=%1
  You say, "Match=0, env0=, env1="
  > say [left(regmatch(abc def,* *,2),0)]env0=%0, env1=%1, env2=%2, env3=%3
  You say, "env0=, env1=, env2=abc, env3=def"

Errors:

  "#-1 Invalid global register." - The <register> was not in the range 0 to 9.

See also: match(), setq(), setr()

& setq()

setq(<register>, <string>)

  This function is used to copy <string> into one of 10 local environment
  variables, <register>, from 0 to 9. Registers are most useful for storing the
  results of complex function evaluations whose data is used repeatedly within
  a single command. The data is later retrieved through the use of v() or with
  the pronouns %0 through %9. The data is only valid for the current command or
  function, since the environment is cleared upon execution of a new command.

  The use of setq() and setr() can greatly improve the efficiency of function
  parsing, reducing the time needed to perform complex evaluations and making
  MARE softcode much more readable in the process.

  This is a purely side-effect function; a blank string is returned.

Example:

  > @va Logbook=%N arrived at [time()].
  > say [setq(0,s(get(Logbook,va)))]'%0' has length [strlen(v(0))].
  You say, "'Rick arrived at Mon Oct 30 14:08:57 2000.' has length 41."

Errors:

  "#-1 Invalid global register." - The <register> was not in the range 0 to 9.

See also: setr()

& setr()

setr(<register>, <string>)

  This function behaves identically to the setq() function, except that it
  returns the <string> being copied to the <register>.

Example:

  > say [setr(0,100)] + [setr(1,50)] = [add(v(0),v(1))]
  You say, "100 + 50 = 150"

Errors:

  "#-1 Invalid global register." - The <register> was not in the range 0 to 9.

See also: setq()

& first()

first(<word list>)
first(<word list>, <delimiter>)

  This function returns the first word in <word list>, or if a <delimiter> is
  specified, all the characters up to but not including the first delimiter.

Examples:

  [first(This is a test)]                            => 'This'
  [first({Would you like coffee, or perhaps tea?})]  => 'Would'
  [first(There are|only three|words here,|)]         => 'There are'

See also: last(), rest()

& rest()

rest(<word list>)
rest(<word list>, <delimiter>)

  This function returns everything but the first word in <word list>. Words are
  separated by any number of spaces by default, but an optional <delimiter>
  character can be used to specify a different word-separator.

  If <word list> only has one word, then a blank string will be returned.

Examples:

  [rest(This is a test)]             => 'is a test'
  [rest(Example/with/delimiters,/)]  => 'with/delimiters'
  [rest(oneword)]                    => ''

See also: first(), last()

& last()

last(<word list>)
last(<word list>, <delimiter>)

  This function returns the last word in <word list>, that is, everything to
  the right of the last space. An optional <delimiter> character can be used to
  separate words instead of a space.

Examples:

  [last(This is a test)]        => 'test'
  [last(A-delimited-string,-)]  => 'string'
  [last(oneword)]               => 'oneword'

See also: first(), rest()

& extract()

extract(<word list>, <first>, <length>)
extract(<word list>, <first>, <length>, <delimiter>)

  This function extracts <length> words from <word list>, starting at word
  number <first>. The result is a subset of <string> that contains only the
  words specified. Words are numbered starting from 1. The parameter <first>
  may contain negative numbers.
  
  An optional delimiter character can be used to separate words. By default,
  any number of spaces will separate words. To use a comma as a <delimiter>,
  surround both <word list> and <delimiter> with {} braces.

Examples:

  [extract(Go west young man,1,2)]        => 'Go west'
  [extract(abc 123 def 456 ghi,2,3)]      => '123 def 456'
  [extract(A long list of words,3,999)]   => 'list of words'
  [extract(A@really@neat@example,2,2,@)]  => 'really@neat'
  [extract(a b  c d,2,2)]                 => 'b  c'
  [extract(a-b--c-d,1,3,-)]               => 'a-b-' (Third word is null)
  [extract(a b c,-1,3)]                   => 'a' (Returns words -1, 0, 1)

Errors:

  "#-1 Out of range." - The <length> specified was negative.

See also: insert(), remove(), replace(), swap()

& remove()

remove(<word list>, <first>, <length>)
remove(<word list>, <first>, <length>, <delimiter>)

  This function is the opposite of extract(), returning the string <word list>
  with <length> words removed starting at word position <first>. Words are
  numbered starting from 1.
  
  An optional delimiter character can be used to separate words. By default,
  any number of spaces will separate words.

Examples:

  [remove(This is a very nice day.,4,1)]  => 'This is a nice day.'
  [remove(1 3 7 9 12 15,5,100)]           => '1 3 7 9'
  [remove(a b  c d,2,2)]                  => 'a d'
  [remove(a-b--c-d,2,2,-)]                => 'a-c-d'
  [remove(a b  c d,-1,3)]                 => 'b  c d' (Removes words -1, 0, 1)

Errors:

  "#-1 Out of range." - The <length> specified was negative.

See also: extract(), insert(), replace(), swap()

& insert()

insert(<word list>, <first>, <string>)
insert(<word list>, <first>, <string>, <delimiter>)

  This function inserts <string> into <word list> in front of word position
  <first>. The <string> can be any number of words in length.
  
  If <first> is 1 or less, then <string> is prepended to the list. Similarly,
  <string> is appended if <first> is greater than the last word number in the
  list. Words are numbered starting from 1.

Examples:

  [insert(This is a nice day.,4,very)]  => 'This is a very nice day.'
  [insert(1 2 3 4 5,3,many words)]      => '1 2 many words 3 4 5'
  [insert(1 2 3 4 5,-2,prepend)]        => 'prepend 1 2 3 4 5'
  [insert(1 2 3 4 5,10,append)]         => '1 2 3 4 5 append'
  [insert(1.2.3.4.5,3,6,.)]             => '1.2.6.3.4.5'

See also: extract(), remove(), replace(), swap()

& replace()

replace(<word list>, <position>, <string>)
replace(<word list>, <position>, <string>, <delimiter>)

  This function replaces the <position>'th word in <word list> with <string>
  and returns the result. The word previously at that position is removed.

  If <first> is less than 1, then <string> is prepended to the list. Similarly,
  <string> is appended if <first> is greater than the last word number in the
  list. Words are numbered starting from 1.

Examples:

  [replace(It is cold outside today.,3,hot)]  => 'It is hot outside today.'
  [replace(1 2 3 4 5,3,many words)]           => '1 2 many words 4 5'
  [replace(1 2 3 4 5,-2,prepend)]             => 'prepend 1 2 3 4 5'
  [replace(1 2 3 4 5,10,append)]              => '1 2 3 4 5 append'
  [replace(a-b--c-d,3,X,-)]                   => 'a-b-X-c-d'

See also: extract(), insert(), remove(), swap()

& swap()

swap(<word list>, <position1>, <position2>)
swap(<word list>, <position1>, <position2>, <delimiter>)

  This function swaps the word at <position1> with the word at <position2> in
  <word list> and returns the result. If a delimiter character is not
  specified, multiple spaces before each word in the list are preserved.

  Swapping with <position1> or <position2> less than or greater than the number
  of words in the list will either prepend, append, or have no effect on the
  resulting string, respectively. Words are numbered starting from 1.

Examples:

  > say [swap(Would you like cream with your coffee sir?,4,7)]
  You say, "Would you like coffee with your cream sir?"

  [swap(apple pear banana orange,2,5)]  => 'apple banana orange pear'
  [swap(banana orange pear apple,4,0)]  => 'apple banana orange pear'
  [swap(out of bounds swap,0,5)]        => 'out of bounds swap'
  [swap(a-b-c-d,2,4,-)]                 => 'a-d-c-b'
 
See also: extract(), insert(), remove(), replace()

& sort()

sort(<word list>)
sort(<word list>,<sort type>)
sort(<word list>,<sort type>,<input delim>,<output delim>)

  This function takes a list of words, numbers, or #dbref's in <word list> and
  sorts them into ascending order. Case-insensitive alphanumeric order is used
  for words and numeric order is used for numbers and #dbref's. For #dbref's,
  only the number after the # symbol is compared.
  
  <sort type> may be used to specify the type of sort to perform. Use the type
  'a' for alphanumeric comparisons, 'i' for case-insensitive alphanumeric, 'n'
  for numeric, 'f' for floating-point numeric, and 'd' for #dbref. If <sort
  type> is left blank, the sort() function will automatically determine the
  type of sort to perform depending on the elements in <word list>, using case-
  insensitive alphanumeric if the elements contain mixed types.

Examples:

  [sort(2 11 5 32,n)]     => '2 5 11 32'
  [sort(2 11 5 32,a)]     => '11 2 32 5'
  [sort(a #9 #-1 #78,d)]  => 'a #-1 #9 #78'
  [sort(16 a 8,,,+)]      => '16+8+a' (Used case-insensitive alphanumeric sort)

& setdiff()

setdiff(<list1>,<list2>)
setdiff(<list1>,<list2>,<input delim>,<output delim>)

  This function returns the difference of two sets of words--i.e. the elements
  in <list1> that are not in <list2>. If <list1> contains duplicate words, then
  each occurrance of a matching word is removed from <list1>, and all other
  words remain unchanged. Words are matched case-insensitive.

Examples:

  [setdiff(1 2 3,2 4 6)]                  => 1 3
  [setdiff(#3 #17 #19 #25 #180,#17)]      => #3 #19 #25 #180
  [setdiff(Three and seven and ten,and)]  => Three seven ten

See also: setinter(), setunion()

& setinter()

setinter(<list1>,<list2>)
setinter(<list1>,<list2>,<input delim>,<output delim>)

  This function returns the intersection of two sets of words--i.e. the
  elements that are both in <list1> and <list2>. The resulting set will not
  contain any duplicate words. Words are matched case-insensitive.
  
Examples:

  [setinter(1 2 3,2 4 6)]       => 2
  [setinter(a b c d,A C E)]     => a c
  [setinter(1 2 6 6 8,6 6 10)]  => 6

See also: setdiff(), setunion()

& setunion()

setunion(<list1>,<list2>)
setunion(<list1>,<list2>,<input delim>,<output delim>)

  This function returns the union of two sets of words--i.e. the elements in
  either <list1> and <list2> minus any duplicate elements. This function can be
  used with an empty set {} for <list2> to remove all duplicate words in a
  list. Words are matched case-insensitive.

Examples:

  [setunion(1 2 3,2 4 6)]    => 1 2 3 4 6
  [setunion(a b c d,A C E)]  => a b c d E
  [setunion(12 4 7 4 9,{})]  => 12 4 7 9

See also: setdiff(), setinter()

& mid()

mid(<string>, <first>, <length>)

  This function returns a segment of <string>, starting at character position
  <first> and up to <length> characters long. Characters are numbered starting
  from 0.

  As with all functions dealing with characters, the <first> and <length>
  parameters can not have negative numbers.

Examples:

  [mid(abcde,1,3)]    => 'bcd'
  [mid(01234,3,999)]  => '34'

Errors:

  "#-1 Out of range." - The <first> or <length> parameters were negative.

See also: delete()

& delete()

delete(<string>, <first>, <length>)

  This function is the opposite of mid(), returning the original <string> with
  <length> characters removed, starting at character position <first>.
  Characters are numbered starting from 0.

  As with all functions dealing with characters, the <first> and <length>
  parameters can not have negative numbers.

Examples:

  [delete(abcde,1,3)]    => 'ae'
  [delete(01234,3,999)]  => '012'

Errors:

  "#-1 Out of range." - The <first> or <length> parameters were negative.

See also: mid()

& pos()

pos(<substring>, <string>)

  This function returns the first character position that <substring> is found
  in <string>, with the first character starting from 1. If no matches are
  found, then a 0 is returned.

Examples:

  [pos(man,superman)]     => '6'
  [pos(needle,haystack)]  => '0'
  [pos(c,flags(v(#)))]    => '2' (Assuming %# is a player and connected)

See also: lpos()

& lpos()

lpos(<string>, <character>)

  This function returns a list of the positions that <character> occupies in
  <string>, with the first character position being 0. Note that this differs
  from the pos() function in both the character numbering and order of
  parameters, but is more consistent with functions such as mid() and delete().

  A blank string is returned if no match is found. Matching characters are
  case-sensitive.

Examples:

  [lpos(avocado,a)]     => '0 4'
  [lpos(baklava,a)]     => '1 4 6'
  [lpos(a-bc-d-efg,-)]  => '1 4 6'
  [lpos({A man a plan a canal, Panama},a)]      => '3 6 10 13 16 18 23 25 27'
  [lpos(Supercalifragilisticexpealidocious,y)]  => ''

See also: pos()

& left()

left(<string>, <length>)

  This function returns the first <length> characters from the left-hand side
  of <string>. No padding is added if <length> is bigger than the size of
  <string>. A blank string is returned if <length> is less than 1.

Examples:

  [left(foobar,3)]    => 'foo'
  [left(flipper,10)]  => 'flipper'
  [left(string,0)]    => ''

See also: ljust(), right()

& right()

right(<string>, <length>)

  This function returns the last <length> characters from the right-hand side
  of <string>. No padding is added if <length> is bigger than the size of
  <string>. A blank string is returned if <length> is less than 1.

Examples:

  [right(Booyah!,4)]    => 'yah!'
  [right(dinosaur,10)]  => 'dinosaur'
  [right(string,0)]     => ''

See also: left(), rjust()

& ljust()

ljust(<string>, <width>)
ljust(<string>, <width>, <fill>)

  This function left-justifies <string> in a field of <width> characters and
  returns the result. If the length of <string> is smaller than <width>,
  padding will be appended to the right until the size is met. If <string> is
  too big for <width> columns, then the rightmost end of <string> will be
  truncated to fit.

  An optional <fill> character can be used for padding instead of a space.

Examples:

  [ljust(Dragon Egg,12)]      => 'Dragon Egg  '
  [ljust(Black Cauldron,12)]  => 'Black Cauldr'
  [ljust(Basilisk,12,.)]      => 'Basilisk....'

Errors:

  "#-1 Out of range." - The <width> specified was not between 0 and 8000.

See also: center(), justify(), left(), rjust()

& rjust()

rjust(<string>, <width>)
rjust(<string>, <width>, <fill>)

  This function right-justifies <string> in a field of <width> characters and
  returns the result. If the length of <string> is smaller than <width>,
  padding will be prepended to the left until the size is met. If <string> is
  too big for <width> columns, then the leftmost end of <string> will be
  truncated to fit.

  An optional <fill> character can be used for padding instead of a space.

Examples:

  [rjust(Steak & Eggs,14)]       => '  Steak & Eggs'
  [rjust(Strawberry Mousse,14)]  => 'awberry Mousse'
  [rjust(Calamari,14,.)]         => '......Calamari'

Errors:

  "#-1 Out of range." - The <width> specified was not between 0 and 8000.

See also: center(), justify(), ljust(), right()

& center()

center(<string>, <width)
center(<string>, <width>, <fill>)

  This function centers <string> in a field of <width> characters and returns
  the result. If the length of <string> is smaller than <width>, padding will
  be applied both before and after the string to fill up to <width> characters
  in total. If <string> is too big for <width> columns, then the rightmost end
  of <string> will be truncated to fit.

  An optional <fill> character can be used for padding instead of a space.

Examples:

  > @emit .[repeat(-,40)].%R|[center(* Hall of Fame *,40)]|%R`[repeat(-,40)]'
  .----------------------------------------.
  |            * Hall of Fame *            |
  `----------------------------------------'

  [center(Foobar,15)]              => '    Foobar     '
  [center(=*< Menu >*=,20,-)]      => '----=*< Menu >*=----'
  [center(Center of Commerce,12)]  => 'Center of Co'

Errors:

  "#-1 Out of range." - The <width> specified was not between 0 and 8000.

See also: justify(), ljust(), rjust()

& justify()

justify(<text>, <width>, <line>)

  This multi-part function fully-justifies <text> line by line within a maximum
  field of <width> characters. Words that won't fit on a line will be moved to
  the next line, and all spaces at the end of each line are trimmed. <Text> can
  be any amount of text, spaces and returns up to a maximum of 8000 characters.
  The function returns one string for the specified <line> number of the text,
  which varies depending on the size of <width>.

  Passing in a '0' for <line> will report the total number of lines this
  function will print for the given <text>. You can output each line in your
  own formatting by incrementing <line> by 1 until the total is reached using
  '@foreach lnum(x,1)', where 'x' is the total number of lines. Printing any
  line above the total for a particular <text> will return a blank string.

  For fully-formatted output, you can use ljust() to automatically insert
  spaces at the end of each result to fill up <width> columns.

Example:

  > say [justify(v(desc),60,0)]
  You say, "4"
  > @foreach lnum(4,1)=say %[ljust(justify(v(desc),60,v(0)),60)]
  You say, "Many are my names in many countries. Mithrandir among the   "
  You say, "Elves, Tharkun to the Dwarves, Olorin I was in my youth in  "
  You say, "the West that is forgotten, in the South Incanus, in the    "
  You say, "north Gandalf, to the East I go not.                        "

Errors:

  "#-1 Out of range." - The <width> specified was not between 1 and 8000.
  "#-1 Bad line number." - The <line> parameter was negative.

See also: center(), ljust(), rjust()

& trim()

trim(<string>)
trim(<string>, <trim style>)
trim(<string>, <trim style>, <character>)

  This function will trim trailing and/or leading characters from the specified
  <string> and return the result. By default, only spaces at the beginning and
  end of the string are removed. An optional <trim style> tells which side of
  the string to strip characters, and an optional <character> tells to trim a
  different character other than a space.

  The following values for <trim style> are recognized:
    'B'  Trim both ends of the string (the default).
    'L'  Trim only the left end of the string.
    'R'  Trim only the right end of the string.

Examples:

  [trim({ a b  c d })]    => 'a b  c d'
  [trim({ a b  c d },L)]  => 'a b  c d '
  [trim(-a-b--c-d-,B,-)]  => 'a-b--c-d'

& secure()

secure(<string>)

  This function returns a secure version of <string>, replacing all
  occurrences of the following characters ()[]{}^$%;,\ with spaces.
  
  Secure strings are beneficial when working with queue commands such as
  @force and @wait. It prevents strings entered by players from causing
  undesired side-effects depending on when the function is evaluated in the
  queue. For example, @force executes a number of commands separated by a
  semicolon. But if the function you evaluate contains a semicolon, it can
  unexpectedly split a command to the point where the player can enter whatever
  command he wants the object to run.

  If a wizard-object contained this code, a malicious user could execute the
  following commands to examine other objects or even nuke players. The example
  below demonstrates this security hole:

  > @va object=$view *:@wait 1={@print Contents of [v(0)]:}
  > view Text
  Contents of Text:
  > view Text;say Hi
  Contents of Text
  Object says "Hi:"

  If the [v(0)] function was secured, the following safely results with minimal
  display problems and no side-effects:

  > @va object=$view *:@wait 1={@print Contents of [secure(v(0))]:}
  > view Text;@switch haspow(me,Nuke)=1,{@nuke Player}
  Contents of Text @switch haspow me Nuke =1  @nuke Player :

  It is instead easier to correct the problem at the queue-evaluation stage by
  inserting an extra % before the [v(0)]. This forces [v(0)] to be evaluated
  after the @wait command and not before, and no side-effect occurs.

  > @va object=$view *:@wait 1={@print Contents of %[v(0)]:}
  > view Text;@redir v(#)={examine me};
  Contents of Text;@redir v(#)={examine me};:

  See 'help Queue' to learn more about adverse effects during function
  evaluation on the command queue.

See also: Queue

& strip()

strip(<string>)

  This function returns <string> with all ANSI escape sequences and color codes
  stripped out. All other characters in the string remain unaffected.

Example:

  [unparse(#42)]         => '[33mN[32me[m[32mx[36mu[1ms[37m(#42RDJX)[32m'
  [strip(unparse(#42))]  => 'Nexus(#42RDJX)'

See also: ansi()

& edit()

edit(<text>, <pattern>, <replacement>)
edit(<text>, ^, <string to prepend>)
edit(<text>, $, <string to append>)

  This function returns <text>, replacing all occurrences of the substring
  <pattern> with the string <replacement>. It works much in the same manner as
  @edit, except that the substitutions can be performed on any string rather
  than restricted to an attribute.

  If the <pattern> is either ^ or $, the <replacement> string will be prepended
  or appended to <text>, respectively. Pattern matching is case-sensitive.

Examples:

  [edit(This is a test.,is,Is)]  => 'ThIs Is a test.'
  [edit(aaAaAaaAaAaa,aAa,---)]   => 'a---Aa---Aaa'
  [edit(locate,^,deal)]          => 'deallocate'
  [edit($100,$,{,000})]          => '$100,000'

See also: @edit

& comp()

comp(<string1>, <string2>)

  Compares two strings alphabetically. It returns 0 if they are identical, -1
  if <string1> comes before/precedes <string2>, or 1 if <string1> comes after
  <string2> alphabetically. All comparisons are case-sensitive; all capital
  letters precede lowercase letters, and all symbols are arranged via their
  ASCII character values.
  
  Note: Numbers are also treated as strings. The string "1580" is less than
        "625" because '1' is less than '6'.

Examples:

  [comp(aardvark,antlion)]   => '-1'
  [comp(regional,region)]    => '1'
  [comp(Hannibal,hannibal)]  => '-1'
  [comp(0042,42)]            => '-1'
  [comp(1234,1234)]          => '0'

See also: match(), ncomp()

& lnum()

lnum(<amount>)
lnum(<amount>, <start>)
lnum(<amount>, <start>, <step>)

  This function generates a space-separated list of <amount> numbers starting
  at the value <start>, or 0 if unspecified. The numbers returned increment by
  <step> numerically, or by 1 if unspecified. There is no limit the amount of
  numbers returned except for the total length of the result, which can be no
  greater than 8000 characters. Floating point numbers can be used for <start>
  and <step>.

Examples:

  [lnum(4)]         => '0 1 2 3'
  [lnum(4,6)]       => '6 7 8 9'
  [lnum(5,10,0.5)]  => '10 10.5 11 11.5 12'
  [lnum(5,2,-3)]    => '2 -1 -4 -7 -10'
  [lnum(3,7.8,0)]   => '7.8 7.8 7.8'

& repeat()

repeat(<string>, <number>)

  This function simply repeats <string> by <number> number of times. No spaces
  are inserted between each repetition. There is no limit to the number of
  repeats except for the total length of the result, which can be no greater
  than 8000 characters.

Examples:

  [repeat(foo,2)]     => 'foofoo'
  [repeat(-,40)]      => '----------------------------------------'
  [repeat(spc(2),3)]  => '      '
  [repeat(string,0)]  => ''

Errors:

  "#-1 Out of range." - The <number> specified was negative.

See also: spc()

& spc()

spc(<number>)

  This function generates a string with <number> blank spaces. <number> can be
  from 0 to 8000. It can be used as a substitute for multiple %B pronouns.

Examples:

  [spc(10)]           => '          '
  Multi[spc(3)]Space  => 'Multi   Space'

See also: repeat()

& chr()

chr(<number>)

  Returns a printable character equivalent to the ASCII value <number>, which
  must be a number in the range 32 to 126. Numbers fall in the range 48-57,
  uppercase characters 65-90, and lowercase characters 97-122.

  Only wizards are able to use chr() with non-printable control or graphics
  characters for a full range from 1 to 255.

  The reverse of this process is [ascii()], which takes a character and prints
  its numeric value.

Examples:

  [chr(33)]   => '!'
  [chr(50)]   => '2'
  [chr(65)]   => 'A'
  [chr(120)]  => 'x'
  [chr(126)]  => '~'

See also: ascii()

& ascii()

ascii(<character>)

  The opposite of chr(), this function returns the numeric ASCII value of a
  character (number, letter, or symbol). Only the first character from the
  string will be converted. A blank string will return 0.

  Note: If a string begins with an ANSI color code/escape sequence, the value
        returned might be 27 (the escape character).

Examples:

  [ascii(A)]        => '65'
  [ascii(z)]        => '122'
  [ascii({ })]      => '32'
  [ascii(chr(60))]  => '60'

See also: chr()

&& esc(), Animation

esc(<string>)

Powers: Animation

  Returns a string of the form "ESC [ <string>", which represents the beginning
  to an ANSI control sequence (CSI). Only wizards may use this function.

  Possible values for <string> are a set of numbers separated by semicolons,
  terminated with a letter or special symbol. Here is a list of ANSI escape
  codes and their meanings.
  
  For all # characters below, an optional number can be specified as the
  parameter. If the number is unspecified, all screen rows and columns for
  cursor positioning default to 1 and everything else defaults to 0.

Cursor Positioning:

  #A     Cursor Up #                 #G     Jump to column #
  #B     Cursor Down #               #d     Jump to row #
  #C     Cursor Right #              #;#H   Jump to Row#, Column#
  #D     Cursor Left #
  #E     Cursor Down #, Column 1
  #F     Cursor Up #, Column 1

Character Erase:

  J      Erase from cursor position to end of display
  1J     Erase from start of display to cursor position
  2J     Erase entire display

  K      Erase from cursor position to end of line
  1K     Erase from start of line to cursor position
  2K     Erase entire line

  #X     Erase # characters to the right of and including the cursor

Insert and Delete:

  #L     Insert # Lines at cursor position
  #@     Insert # Characters at cursor position

  #M     Delete # Lines at cursor position
  #P     Delete # Characters at cursor position

Scroll Region:

  #;#r   Limit scroll region from Rows # to #. Omitting the values here
         restores scrolling to the entire screen.

Cursor Attributes:

  s      Save cursor position and attributes
  u      Restore cursor position and attributes

  #;#;...;#m  Set cursor attribute mode(s) from one of the following:

    0    All Attributes Off, Default Color
    1    Intensity (Bold) On
    2    Half-Intensity On
    3    Italics On
    4    Underline On
    5    Blinking On
    6    Rapid Blink On
    7    Reverse Video Mode On
    8    Concealed (Invisible) Text On
    21   Intensity Off
    23   Italics Off
    24   Underline Off
    25   Blinking Off
    27   Reverse Off
    28   Concealed Text Off

    3x   Foreground Color (30-37),
    4x   Background Color (40-47), where x is 0 to 7:

    0=Black, 1=Red, 2=Green, 3=Yellow, 4=Blue, 5=Purple, 6=Cyan, 7=White

  Note: There are many other ANSI codes not listed here--these are only the
        basic set. The support for ANSI codes depends on the user's terminal
        program, and not all codes will be shown alike on all terminals.

Examples:

  [esc(3;20r)]  => Sets the scroll region to rows 3-20 inclusive.
  [esc(44m)]    => Sets the background color for new text to Blue.
  [esc(5;15H)]  => Jump to row 5, column 15. Rows are numbered starting at 1.
  [esc(2J)]     => Erases the entire display to the current background color.
  [esc(s)]      => Saves current cursor position, color, and attributes.

  [esc(1;5;33;44m)]  => Sets the cursor attributes to Bold, Blink, Yellow
                        foreground, and Blue background.
  [esc(m)]           => Turns off the aforementioned attributes.

Errors:

  "#-1 Permission denied." - The user does not have the Animation power.

See also: csi(), term()

&& csi(), Animation

csi(<string>)

Powers: Animation

  Returns a string of the form "ESC <string>", which represents a non-ANSI
  escape sequence. In other words, it prepends the escape character (27) to the
  beginning of <string> and returns the result.

  Such escape sequences widely vary from terminal to terminal and should only
  be used when you know the terminal type of the player on the other end.
  Typical escape sequences include the following:

    c          Complete reset of the controlling terminal (use with caution)
    7          Save cursor position and attributes
    8          Restore cursor position and attributes
    D          Perform a linefeed
    E          Carriage Return + Linefeed
    M          Reverse index (screen scrolls down if at top of screen)
    #8         DEC screen alignment test (fills entire screen with E's)
    ]PnRRGGBB  Sets (in hexadecimal) palette color for n, RGB = 00 to FF
    ]R         Restore color palette

  Note: csi() is really a misnomer. CSI stands for Control Sequence Introducer
        and equals the 2-byte phrase "ESC [". Because esc() was first used in
        TinyMARE to accomplish this, esc() really performs a CSI and csi()
        really performs an Escape.

Examples:

  [csi(c)]            => Resets all terminal attributes and clears the screen.
  [csi({]P78bff00})]  => Changes the default text color (7) to neon green.
  [csi({]PFb0d0ff})]  => Changes the bold text color (F=15) to sky blue.

Errors:

  "#-1 Permission denied." - The user does not have the Animation power.

See also: esc(), term()

& ansi()

ansi(<color>, <string>)

  Returns <string> in the color specified by <color>. <color> can contain a
  number or a color code consisting of letters and symbols. Text written after
  the [ansi()] function will revert back to the previous color selected (via
  the %X pronoun).
  
  The color code format is consistent with the @color object attribute. See
  'help @color' for further details.

Examples:

  [ansi(!,Ansi Rules)]  => Prints 'Ansi Rules' in reverse script.
  [ansi(*,name(here))]  => Prints the name of the room in rainbow text.
  [ansi(r+,v(desc))]    => Prints your description in bold red lettering.

See also: @color

& isdbref()

isdbref(<string>)

  Returns 1 if the specified <string> is a valid database reference number,
  otherwise 0 is returned. To be valid, the string must begin with a '#' symbol
  and be followed by an integer.  Also, the reference number must currently
  exist in the database as a valid object that has not yet been @destroyed.

Examples:

  [isdbref(#76)]     => 1
  [isdbref(#-1)]     => 0
  [isdbref(#42RAJ)]  => 0
  [isdbref(Chair)]   => 0
  [isdbref(800)]     => 0

See also: isnum(), isword()

& isnum()

isnum(<string>)

  Returns 1 if the specified <string> contains a valid number. A valid number
  is an integer or real number that contains all digits, an optional '-' or '+'
  sign at the beginning, and an optional decimal point '.' between two digits.

  A 0 is returned if <string> is not a number, or if <string> contains any
  spaces or letters including those in exponential notation.

Examples:

  [isnum(42)]        => 1
  [isnum(+586)]      => 1
  [isnum(-2002.60)]  => 1
  [isnum(Blee)]      => 0
  [isnum(60 T)]      => 0
  [isnum(1.34e+6)]   => 0

See also: isdbref(), isword()

& isword()

isword(<string>)

  Returns 1 if every character in the specified <string> is a letter, otherwise
  0 is returned. Valid words cannot have spaces, digits, or symbols in them.

Examples:

  [isword(Party)]         => 1
  [isword(yellow-green)]  => 0
  [isword(Not a word)]    => 0

See also: isdbref(), isnum()

& flip()

flip(<string>)

  Returns <string> with all its contents printed backwards from right to left.

Examples:

  [flip(abcdefg)]         => 'gfedcba'
  [flip(rettalP oofooF)]  => 'Foofoo Platter'

See also: wordflip()

& wordflip()

wordflip(<word list>)
wordflip(<word list>, <delimiter>)

  Reverses the order of words in <word list>. The letters within the words stay
  in correct order, however the words themselves are completely reversed.

  An optional delimiter character can be used to separate words. By default,
  any number of spaces will separate words.

Examples:

  [wordflip(This is a test)]  => 'test a is This'
  [wordflip(abc-123-def,-)]   => 'def-123-abc'
  [wordflip(lwho())]          => Returns the dbref#'s of connected players
                                 from the longest online time to the shortest.

See also: flip()

& scramble()

scramble(<string>)

  This function randomly scrambles the contents of <string>, returning a random
  permutation of its characters. Note that this function does not pay any
  attention to spaces or other special characters--it will scramble these just
  like any other.

Examples:

  [scramble(abcdef)]            => 'cfaedb', 'efbdac', 'adcebf', etc...
  [scramble(Testing 1 2 3...)]  => 'n. .13.eg s2tiT '

See also: shuffle()

& shuffle()

& dice()

dice(<number of rolls>, <sides>)

  This function simulates a random roll of dice. It rolls a die with <sides>
  number of sides, <number of rolls> times, and sums the result. Technically,
  it adds a random number between 1 and <sides>, repeats the process <number of
  rolls> times, and prints the grand total.
  
  For example, [dice(2,6)] would roll a "2d6" -- two six-sided dice, generating
  a result from 2 to 12. Specifying 0 <number of rolls> will always return 0.

Errors:

  "#-1 Out of range." - The <number of rolls> was not between 0 and 1000.

See also: rand()

& rand()

rand(<number>)

  Returns a random integer between 0 and <number> minus 1. If <number> is less
  than 2, this function will always return 0. The maximum valid integer for
  <number> is 2147483647 (or 2^31 - 1).

See also: srand(), dice()

& srand()

srand(<number>,<seed>,<index>)
srand(<number>,<seed>,<index>,<count>)

  Returns a set of random integers that fall between the range 0 and <number>
  minus 1. The list of numbers is pulled from a set of random integers seeded
  with a <seed> number that can be positive or negative. The same set is
  generated for the same <seed> value used.
  
  <count> numbers are displayed starting from index <index> in the generated
  set. You can only retrieve a maximum of 1000 numbers per function call. Only
  10,000 random numbers are generated in a set per individual <seed>, and an
  error will occur when trying to retrieve index 10,000 or above. Index numbers
  start at 0.
  
Examples:

  [srand(7,40,0)]     => '3'
  [srand(7,40,1)]     => '0'
  [srand(7,40,0,10)]  => '3 0 1 6 3 5 2 6 0 6'
  [srand(7,42,0,10)]  => '1 2 4 5 4 3 5 5 0 0'

Errors:

  "#-1 Out of range." - The <count> specified is greater than 1000, or an index
                        outside the range 0 to 9999 was requested.

See also: rand()

& randword()

randword(<word list>)
randword(<word list>, <delimiter>)

  This function pulls a random word out from <word list> and returns the
  result. The frequency of occurrence for each word depends on the number of
  words in the list.

  An optional delimiter character can be used to separate words. By default,
  any number of spaces will separate words.

Examples:

  [randword(a1 b2 c3 d4)]    => 'a1', 'c3', 'c3', 'b2', 'a1', etc...
  [randword(a b-c d-e f,-)]  => 'e f', 'e f', 'c d', 'e f', 'a b', etc...
  [name(randword(lwho()))]   => Returns the name of a random connected player.

See also: rand()

& switch()

switch(<expression>, <pat1>, <res1>, <pat2>, <res2>, ..., <default>)

  This function returns a result based on the value of <expression>. 

  First, <expression> is evaluated and computed. It then attempts a match()
  between <expression> and <pattern1>. If this match succeeds, then the string
  <result1> is displayed. Otherwise, it attempts a match() between <expression>
  and <pattern2>, and so forth. If it finds no matches, then the last argument
  of the function, <default>, will be printed.

  The pattern strings can contain '*' and '?' wildcards, as well as begin with
  boolean characters '!', '<', or '>' as in the [match()] function. An argument
  is determined to be a <pattern> if there is another argument following it,
  otherwise if it is the last argument to the function, it is the string to be
  printed as <default> if all prior patterns fail to match. The <default>
  parameter is entirely optional.

  Patterns are matched in order from left to right. If more than one pattern
  can match, only the leftmost result is printed. Remember that curly braces
  are necessary around arguments that contain a comma.

Examples:

  > say [switch(add(3,4),5,Five,6,Six,7,Seven,8,Eight)]
  This prints 'Seven'. The expression 'add(3,4)' evaluates to 7, and from the
  patterns 5, 6, 7, and 8, only '7' matches. The resulting string after the 7,
  'Seven', is the end result of the function.

  > say [switch(mul(3,4),5,Five,6,Six,7,Seven,8,Eight)]
  This returns a blank string. [mul(3,4)] evaluates to 12, and none of the
  listed patterns match 12. There is also no <default> string listed, so the
  end result is a blank string returned.

  > say [switch(mul(3,4),5,Five,6,Six,7,Seven,8,Eight,No Pattern Matched)]
  This function prints 'No Pattern Matched'. It is exactly the same as the
  above, with the extra <default> argument in place. Note that the phrase
  'No Pattern Matched' is NOT compared as a pattern because no argument follows
  it in the list.

  > say [switch(Radix,>s,1,!r*,2,*r*,3,r*x,4)]
  This function returns '3'. The patterns here are >s, !r*, *r*, and r*x.
  Of these patterns, only *r* and r*x return true. Since [match(Radix,*r*)] is
  the first match that returns true, our third result, '3', is returned.

Advanced Switching:

  Because the switch() function is really a glorified match(), it is important
  to know that matching can go both ways. By flipping the <pattern> and
  <expression> arguments, you can have multiple expressions that match for the
  same output result. For instance, look at the following:

  > say [switch(1,gt(idle(me),3600),Idle,lt(onfor(me),500),Just Got In,
  >      hasflag(me,connected),Alive and Well,Duly Disconnected)]

  The above switch() has three expressions, all which are evaluated and matched
  with 1. First, the expression [gt(idle(me),3600)] checks if your idle time is
  greater than 3600 seconds. If so, that expression will evaluate to a 1 and
  match our first argument, and the switch() will print 'Idle'. If that didn't
  match, it'll evaluate the second expression [lt(onfor(me),500)] for a 1. If
  your online time is less than 500 seconds, it will print 'Just Got In'.
  Otherwise, it will check to see if you are connected, and print 'Alive and
  Well' if you are, or the default text 'Duly Disconnected' will appear if you
  aren't.

  Therefore the need for nested ifelse() functions has been eliminated with one
  switch(). With this method, it is easiest to use a '1' as the first argument,
  that way you can test for truth for each pattern and use !function() to test
  for zero.

See also: @switch

& foreach()

foreach(<word list>, <function>)
foreach(<word list>, <function>, <input delim>)
foreach(<word list>, <function>, <input delim>, <output delim>)

  This function prints a space-separated list of results from <function>, for
  each word in <word list>. The word appears in the function as %0 or [v(0)]
  and is called as many times as the number of words in <word list>.

  Note that <function> must contain a parsable string that is not evaluated by
  the parser at execution time. In other words, it accepts [] and %-subsitution
  so it can evaluate the function differently for each word. For example, the
  function parser will predicate the function [foreach(lnum(4),add(v(0),3))]
  as: '[foreach(0 1 2 3,3)]' before it even gets to foreach(), because %0 at
  the time was 0. The correct method would be to place [] around the add().

  An optional input and output delimiter can be specified as the separator in
  the word list. <input delim> is used to delimit the words in <word list>, and
  <output delim> is printed between every non-null word in the output string.
  The default for both is any number of spaces between words.
  
Examples:

  [foreach(lnum(4),val=%0)]                  => 'val=0 val=1 val=2 val=3'
  [foreach(1 2 4 8 16,[pow(v(0),2)]!)]       => '1! 4! 16! 64! 256!'
  [foreach(1|2|3|4|5,[sub(10,v(0))],|,-)]    => '9-8-7-6-5'
  [foreach(lnum(6),[if(mod(v(0),2),v(0))])]  => '1 3 5'

  [foreach(lwho(),[name(v(0))])]  => Returns the names of all players online.

Note:

  The %0 variable is used within foreach() and is returned to its original
  state when the function completes. This could pose a problem for a user-
  defined function if <function> inside the foreach() needs to retrieve the
  original %0. The recommended solution is to pick an unused environment such
  as %9, and [setq(9,v(0))] to temporarily save %0. The function inside foreach
  can then use [v(9)] or %9 to retrieve the otherwise unaccessible %0.

See also: oper()

& oper()

oper(<word list>, <starting value>, <function>)
oper(<word list>, <starting value>, <function>, <delimiter>)

  This powerful function operates <function> on a list of words in <word list>,
  feeding the result from the previous function back into itself for the next
  evaluation.
  
  Like foreach(), each word appears in <function> as %0 or [v(0)], however
  instead of printing the result of each <function>, the result is saved to an
  environment variable %1 for the next iteration to use. The end result is that
  <function> can operate on both %0 and %1 for each word in the list, and after
  the last word is processed, the final result of <function> will be displayed.

  <starting value> can be used to set the initial value of %1 before the first
  word is processed by <function>. An optional <delimiter> specifies the
  delimiter surrounding the words in <word list>.

Examples:

  > say [oper(lnum(10,1),0,[add(v(0),v(1))])]
  Adds up all the numbers from 1 through 10 and prints the result, '55'. The
  result from each [add()] is stored back in %1 for use by the next operation.

  > say [oper(a b c d e,,%0%1)]
  An interesting effect of oper() allows you to control the output that gets
  displayed. This function returns each word in <word list> in reverse order,
  without spaces between the words.

  > say [oper(lwho(),0,[add(v(1),match(class(v(0)),Wizard))])]
  This function will tally the number of Wizards currently logged in (and
  unhidden) and print the result.

Warning:

  The number of function calls from within an oper() is limited to the value
  MAX_FUNCTIONS in @list config. If not careful, even a small number of words
  in <word list> multiplied with the number of functions in <function> can
  cause a "#-1 Too many functions." error to result. Use %-substitution instead
  of functions whenever possible.

See also: foreach()

&+
 [33m.[1m--[0;32m.[m
 [31m`[1m-  [32m:  [36m.  [35m.-[31m'    [36mOnline[m                                             [34m  __  [m
     [1;32m|[0;36m.[1m'[34m|[0;34m.[35m'        [36mHelptext[m                                          [34m.'[1m..[0;34m`.[m
    [33m.[1m'  [0;34m'  [1;32mi[36mn[33md[31ms     [34mMain Menu[m                                        [34m`.__.'[m

[34mÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[m

Help on Playing the Game:              Building and Coding Topics:

  Getting Started                        Building Commands
  General Information                    Attributes
  Commands                               Functions
  Combat                                 Flags
 
[1;32mType [37m'help <topic>'[32m where <topic> is an option from the list above,[m
[1;32mor type [37m'help topics'[32m for a complete list of topics.[m

&+ Commands

Commands

Set 1: Standard CommandsÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  announce   examine   help       money     put       to
  clear      exits     inventory  move      say       whisper
  drop       give      leave      page      take      whereis
  enter      grab      look       pose      talk      who

Set 2: Out-of-character CommandsÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  +channel   +finger    +motd    +tzone
  +com       +laston    +news    +uptime
  +config    +mail      +term    +version

Set 3: Combat CommandsÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  Set 4: Item List CommandsÄÄÄÄ
                                               ³
  fight   status    weather    map     +lang   ³  items      techs
  cast    save      sector     pick    +party  ³  spells     limits
  use     equip     behavior   search  +sbar   ³  skills     prayers
  stop    unequip   wimpy      run             ³  weapons

See also: Building Commands

&+ Temporary Screen, Combat

Set 3: Combat CommandsÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  Set 4: Item List CommandsÄÄÄÄÄ
                                              ³
  fight   status    weather    map     +sbar  ³  items     techs
  cast    save      sector     pick           ³  spells    limits
  use     equip     behavior   +party         ³  skills    prayers
  stop    unequip   wimpy      +language      ³  weapons

  eat? recite?

&& @advance, Combat

@advance <player>=<technique type>,<technique>,<amount>
@advance <player>=<technique type>,<technique>,<amount>,<levels>
@advance <player>=<technique type>,<technique>,<amount>,<levels>,<limit>

Powers: Combat

  

&& @levelquest, Combat

@levelquest <level>=<quest name>:<position>:<flags>:<description>
@levelquest <level>=<quest name>
@levelquest <player>=<quest name>

Powers: Combat

  This command either defines a new quest, modifies an already existing quest,
  or grants the accomplishment of a level quest to a player. In the first form
  of this command, a <level> for the quest must be specified to add a new
  quest. This command defines a new quest with the name <quest name>, or if
  that name already exists, redefines the entry. <bit position> refers to the
  storyline variable that gets set to a 1 when the player accomplishes the
  levelquest. It is recommended that bitmap positions in the Storyline range
  (2048 and up) be reserved and used for levelquest data, however any position
  greater than 0 is allowed. <bit position> may be set to 0 to define the quest
  for future use (but without any way to accomplish that quest in its current
  state). <flags> are a space-separated list of words that are composed of the
  following: <b>Required</b>: Forces the player to accomplish the levelquest
  before the specified level is reached. This has no effect if the player is
  already above that level when the quest is created. <b>NoEXP</b>: No <a
  href="helptext.html#Experience">Experience Points</a> are granted when the
  player achieves the levelquest. This is usually set in combination with the
  Required flag. <b>LockEXP</b>: A player can never gain more experience than
  that required for the next level until the quest is completed. <b>Global</b>:
  A player may accomplish this quest anytime during his adventuring career,
  before or after that level is reached. A level quest can be removed by
  specifying nothing after the <quest name>.

  The second form of the command actively sets the storyline bits on a
  particular player and invokes the routines for the completion of a
  levelquest. At this time, if the player is currently on the same level as the
  quest is specified, he will instantly gain a certain amount of <a
  href="helptext.html#Experience">Experience Points</a> not exceeding the
  number of points needed for the next level. If his <b>Experience For Next</b>
  was 0 at the time of the quest completion, he will automatically be promoted
  to the next level. See the helpfile on the 'quests' command for more
  information on levelquests.

Examples:

  > @levelquest 56=Abominable Snowman:2048::In recent years, a fearsome frost
  > giant has threatened the snow-capped mountain town of Th'kanaldar, blocking
  > trade routes at the pass. As days grow short, the pass gets more formidable
  > to cross, and the town's citizens begin to suffer the biting cold without
  > any supplies. Defeat the giant and save the town from massive destruction
  > before the Winter moves in.
  Creates a new quest at level 56, using bitmap position 2048 and no special
  flags.

  > @levelquest 20=Coat of Many Colors
  Removes the level 20 quest "Coat of Many Colors" from the database.

See also: quests, Experience

&& @encounters, Combat

@encounters

Flags: Inherit Haven Dbref Combat
Objects: Room, Zone

  TinyMARE's random enemy encounter system is designed to provide 6 levels of
  monster difficulties that are picked at random each time a player enters a
  new room. The @encounters attribute on the destination room or zone
  determines how many of what kind of enemies appear. Enemies are created with
  the Monster flag set, just as if the @enemy command was used in softcode.

  In the @encounters attribute, enemy parents are stored as groups of #dbrefs
  separated by a | or , symbol. Furthermore, groups themselves are separated by
  spaces and can be prefixed by one of several Type= modifiers. The type
  modifier determines if the enemy encounter always appears, or if a random
  encounter is to be chosen from a list of varying difficulties.
  
  Regardless of the modifier, no enemies will be created if the destination
  room contains other players or other enemies with the Monster flag set. Also,
  unless the Always= type modifier is used, enemies will only be created if the
  player hasn't entered the new room in the number of minutes defined by the
  ENCOUNTER_TIME @config variable.
  
Static Encounters:

  Static (non-random) encounters can be specified either without a type
  modifier or with the Always= modifier. They both define a group of enemies
  that should always appear in the room either on each visit (with Always=) or
  after ENCOUNTER_TIME minutes elapse (with no modifier). Always= is usually
  used for boss-room encounters, where a boss enemy is spawned every time
  someone enters the room. There can be as many of these two groups listed in
  @encounters as desired.
  
Random Encounters:

  Random encounters are designed to give the illusion that there are a certain
  number of enemies roaming around in the sector without actually creating
  them until the player arrives. One benefit to random encounters is that
  several player +parties can be going through an area at once and constantly
  be seeing monsters, keeping the monster population from ever being wiped out.

  Three factors determine the number of enemies spawned with each move in a
  sector: Frequency, Spawn-amount, and Rate. Frequency is a value from 0 to 7
  that describes how often an enemy encounter takes place per move. The "Enc"
  column in '@list sectors' shows the default frequency for all sector types
  and can be changed by editing the 'etc/sector.db' system config file. With
  each new room entered, enemies will appear 1 in (8-Frequency) times. For
  instance, a frequency of 5 means that every 3rd room will have enemies, on
  the average. The frequency can be overridden using the Frequency= modifier.

  The Spawn-amount is a number from 0 to 100 indicating the number of full
  enemy groups to be spawned each time an encounter occurs. If unspecified, the
  game will choose a random number between 1 and 6, highly weighted towards 1.
  Use the Spawn= modifier to set a static number of enemy groups spawned per
  encounter.

  The Rate is a number out of 1000 that determines how often an enemy in each
  enemy group will be created. By default, this number is 1000 (100%) but can
  be overridden using the Rate= modifier.

Difficulty Levels: 

  Each enemy group for a random encounter must be specified separately using
  the Level1= through Level6= type modifiers. For each group to be spawned, the
  game randomly chooses a difficulty level from 1 to 6, weighted towards 1.
  The rate of each difficulty level is spawned as follows:

    Level 1:  4651 in 7776 - Common enemies found throughout the sector.
    Level 2:  2101 in 7776 - Less common, these enemies vary in difficulty.
    Level 3:   781 in 7776 - Monsters with moderate difficulty levels.
    Level 4:   211 in 7776 - Difficult enemies, usually above player's level.
    Level 5:    31 in 7776 - Monsters not normally found in this area.
    Level 6:     1 in 7776 - Rare monsters, usually found only in this sector.
  
  Generally, there is one enemy parent listed per difficulty level. However,
  if multiple enemies per Level#= group are specified, then each enemy in the
  group is spawned together. In this case, the Rate= modifier works on an
  individual enemy level and can further randomize which enemies appear.

  Level 6 is reserved for extremely rare enemies: either secret enemies that
  appear only once in a blue moon, or enemies with power and stats well above
  the area's combat level. Such enemies may be impossible to defeat, and
  players should 'run' when encountering these attacks.

Notes:

  Random encounters are spawned by Frequency in addition to all static ones
  specified in the attribute. Static encounters are not governed by Frequency
  or Rate.

  Each #dbref specified must match a valid object parent that has a combat
  status set, or that enemy will never be created.

  You can simulate enemies traveling in packs by placing that enemy #dbref
  several times in a single Level#= group, and then by setting Spawn=1. Use the
  Rate= modifier to add variance to the size of the pack.

  Functions are usable in @encounters, allowing for different templates based
  on night/day, storyline differences, and so on.

  Only the last Frequency=, Spawn=, and Rate= modifier specified in the
  @encounters attribute is used to govern the entire encounter.

  If players die or escape battles frequently, over-population can occur. Use
  the following softcode to destroy forgotten monsters over a period of time:

    > @atime monster=@swi land(!rand(20),!fighting(me))=1,@destroy me

Examples:

  > @encounters here=#2000
  This makes the room produce an enemy with parent #2000 when a player enters
  the room. The player must wait ENCOUNTER_TIME minutes before entering the
  room again, or the enemy will not reappear.

  > @encounters here=#2324|#2324|#236 Always=#2324
  This makes the room produce a Bat (#2324) every time the player enters the
  room. If the player hasn't entered the room in ENCOUNTER_TIME minutes, two
  more bats and a Nuper (#236) will be created.

  > @encounters Katwana Prairie Zone=Level1=#236 Level2=#6360 Level5=#338
  This sets the Katwana Prairie zone object to use random encounters, producing
  Nupers (#236) as the most common, Butterflies (#6360) on difficulty level 2,
  and Mutant Mushrooms (#338) on level 5. The frequency defaults to 5, as
  determined by the "Wilderness" sector type.

  > @encounters zone=Spawn=1 Rate=800 Level2=#2122,#2122,#2122,#2122,#2122
  This makes the sector produce 1 pack (Spawn=1) of up to 5 Gray Wolves (#2122)
  for each room move, 9% of the time (Level2 rate * Frequency=5 rate). Each
  wolf appears in the pack 80% of the time (Rate=800).

See also: @enemy, ENCOUNTER_TIME

&& @mana, Combat

@mana

Flags: Inherit Haven Combat
Objects: Room, Zone

  Sets the parameters on a room or zone for the Draw Points magic system. This
  attribute defines up to 6 integer values that change how Magic Power is
  extracted via the 'draw' command. Each value is of the form Setting=Integer,
  with each group space-separated in the attribute. The available settings are:

    Max=<maxmana>
    Min=<minmana>
    Regen=<manaregen>
    Range=<manarange>
    Surge=<manasurge>
    Charge=<manacharge>

  Each of the 6 above values corresponds to the combat attributes with similar
  names ($maxmana, $minmana, etc). By default all values are set to 0. A room
  cannot be used as a Draw Point until Max= is set greater than 0. If any @mana
  attributes are stored on a Room, its Zone's @mana attribute is bypassed
  completely.

  The partner to the $mana attribute for rooms is the "Drawpoint" Room
  Condition, which contains the current mana capacity present at the location.
  This condition is modified every time a player extracts or infuses the room
  with Magic Power, or once per minute depending on the @mana attribute's
  Regen= value.

  See 'help $maxmana', etc. for help with each attribute's meaning.

Examples:

  > @mana here=Max=100 Regen=5
  Sets a standard room with 100 maximum magic points for players to draw. Its
  capacity will regenerate back to 100 by 5 points per minute if left untouched.

  > @mana here=Max=250 Min=40 Regen=5 Charge=75%
  This room holds 250 maximum magic points, regenerating 5 points per minute.
  The room must have 40 or more points remaining for players to use the Draw
  Event. If a player uses the Recharge Mana Event, he will recharge the room by
  3 points for every 4 Magic Points spent.

  > @mana here=Max=500 Regen=5 Surge=25
  This room contains a powerful field of energy, such that if players tried to
  absorb less than 25 Magic Points from the room, they will be unexpectedly
  forced to extract 25 points (as long as the room has 25 mana remaining).

  > @mana here=Max=1500 Regen=50 Range=80% Surge=60
  This is a good example of an unstable source of mana. A Range of 80% means
  that players can draw between 20% and 180% of their indicated amount with each
  use of the 'draw' command. Worse, if the resulting draw amount happens to be
  below 60, players will be given a surge message and will have to absorb
  between 100% and 180% of that 60 (60-108). If their MP isn't low enough, they
  could take damage for every magic point above their Maximum MP they absorbed.
  Using both Range= and Surge= help keep players in the dark on what the actual
  Surge= cutoff is.

See also: Draw Points, Event Recharge Mana, $mana, $manacharge, $manarange,
          $manaregen, $manasurge, $maxmana, $minmana

&& Spell Attributes, Combat

Spell Attributes

Numerical Values:

  General     Event        Items        Food/Lamps    Equipment    Skills
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  $type       $areaatk     $capacity    $food         $power       $skill
  $color      $fumbleatk   $itemlimit   $foodgroup    $maxpower    $techbase
  $value                   $itemtype1   $spoil        $damage      $techlevel
  $weight                               $spoilcount   $eqhand      $techraise
  $material   $recharge    $pawnvalue                 $shieldatk   $maxpercent
  $flags      $battles                  $lightsrc                  $learn
  $level                   $applyitem   $lighttotal   $hardness
  $icon                    $applyequip  $lightcount   $density     $damp
  $iconcolor  $component1  $applyskill  $lightweight  $resilience  $transmute

String Values:

  $desc      $cost        $cast     $fail      $drop
  $caption   $chantrate   $ocast    $ofail     $odrop
  $command                          $tfail
  $cname     $message     $succ                $ufail
  $usage     $omessage    $osucc    $fumble    $eqfail
  $action                 $tsucc    $ofumble
  $lock      $eventmsg    $remote   $tfumble

See also: Creating Spells

&& $type, Combat

$type <spell>=<number|type>

  This attribute sets the type of spell, item, technique, or piece of equipment
  that covers the slot number <spell> in the Spell Database. It can only be set
  to one of the values found in '@list types'.
  
  Values from '0' to '63' refer to types of equipment that can be wielded or
  worn, while values '64' and above refer to different types of items, tools,
  techniques, spells, and magical artifacts.

  For a newly created spell, the default item type is '0' (Stick).

Example:

  > @addspell 1=Healing Herb
  > $type 1=Item
  This creates a Healing Herb as slot 1 in the Spell Database and makes it a
  usable item (type 65).

  Note: You can also use the alternate syntax '@type $1=Item'.

See also: @addspell

&& $color, Combat

$color <spell>=<number|color-codes>

  A numerical value representing the color of an item in the Spell Database.
  Colors can be chosen from the standard color-codes (listed in 'help @color'),
  or chosen by adding one foreground and one background color together from the
  table below:

     Foreground Colors:                         Background Colors:

       0 - Black       8 - Gray                     0 - Black
       1 - Red         9 - Light Red               16 - Red
       2 - Green      10 - Light Green             32 - Green
       3 - Brown      11 - Yellow                  48 - Brown
       4 - Blue       12 - Light Blue              64 - Blue
       5 - Magenta    13 - Light Magenta           80 - Magneta
       6 - Cyan       14 - Light Cyan              96 - Cyan
       7 - Normal     15 - White                  112 - Gray

  Note: By default, a newly created spell has Color 0. This color shows up as
        normal (gray) text in both the items inventory and during battle.

Examples:

  > $color 1=76
  This selects Light Blue text over a Blue background (64+12).

  > $color 1=11*
  This selects Rainbow text starting with the color Yellow.

  > $color 1=Ry+*
  This selects the same Rainbow text as above but with a red background.

See also: @color, $cname

&& $value, Combat

$value <spell>=<amount>

  This value represents the full price of an item as it would be displayed
  on a menu in a shop. Shops will buy items back for half of this amount with
  variations depending on a player's Bargain skill.
  
  The maximum possible value of an item is 999,999,999 GP. Legendary items and
  items with a value of 0 GP cannot be sold to shops. Items with a value of 1
  GP can be sold for 1 GP.

See also: $pawnvalue

&& $weight, Combat

$weight <spell>=<grams>

  This value represents the carry-weight, or encumberance of an item, in grams.
  The total number of items a player can carry is determined by the maximum
  Carry Weight of the player, which depends on one's Strength and how well
  items are packed into containers. Equipping an item divides that item's
  encumberance by 2, however heavier equipment decreases fighting speed during
  battle and hinders the player's ability to dodge attacks. See the topic 'help
  Carry Weight' for a full explanation of the formula.
  
  This value is equivalent to the @weight attribute that can be set on a #dbref
  object.

See also: Carry Weight, @weight

&& $material, Combat

$material <spell>=<number|type>

  This attribute defines the primary type of material in a piece of equipment
  and judges an equipment's hardness, density, and resilience ratings for melee
  attacks. The material type or value specified must be one from the table
  '@list materials'. In the case that an object consists of more than one
  material, only the most prominent or superior should be set.
  
  Different types of materials can have all kinds of special properties. It is
  generally a good idea to create equipment with plenty of material types so
  that players can choose to equip items with unique properties instead of
  relying solely on higher attack and defense power.

  Newly created items have their material types set to '0' (Eggshell) by
  default, however Eggshell will not be shown in the attribute list unless it
  is a piece of equipment (its $type is from 0 to 63). $material has no effect
  on non-equipment items and therefore is an optional way to match or count
  held items with a certain material type, as required by your storyline.

See also: $density, $hardness, $resilience

&& $flags, Combat

$flags <spell>=<list>

  This attribute holds special flags that change the behavior of an item,
  skill, spell, or technique. <list> is a space-separated list of flags from
  the table below that enables (or disables) special features. Some flags only
  have meanings for a particular item $type.
  
  Legendary  - Signifies an item or equipment's uniqueness in the game. Such an
               item cannot be discarded, given to other players, sold to a
               shop, or otherwise destroyed in battle. Legendary equipment can
               still become damaged during normal attacks, however they can
               always be repaired to New status.

  Quiet      - Prevents an item or spell from displaying a -< Battle >- message
               when the technique is used.

  Fragile    - This item will instantly disappear the moment it is dropped in
               the room. Setting the $drop and $odrop attributes can change the
               message players see.

  Consume    - This flag makes equipment disappear when used as an item in
               combat. Only equipment with $events stored on them can be used
               with the 'use' command. Without this flag, players can use such
               equipment in battle as many times as they want.

  Forged     - Allows equipment to be moulded and reshaped into stronger armor
               and weapons with Blacksmithing skills or at the Forge. This flag
               normally indicates a piece of equipment was created by a player.

  Cursed     - Inhibits the ability to unequip a piece of equipment from the
               body. Such a cursed item can only be removed with the Lift Curse
               event or by destroying the equipment. 

  Autouse    - For weapons with $events, this automatically triggers each
               $event on the equipment every time the player successfully hits
               his opponent. Each event triggers regardless of the timers set
               between multiple events. This flag also prohibits an equipment's
               events from being triggered with the 'use' command.

  Master     - Used to indicate that a specific spell or technique cannot be
               leveled up, or that a skill cannot be increased in percentage.
               Such skills will not show their Mastery % on the 'skills' sub-
               screens and cannot be selected with the 'study' command.

  Unique     - Signifies an item that was created uniquely in the entire game,
               independent of the storyline. Such items will be saved from
               destruction by being dropped into the room automatically if
               their container disappears. Players carrying these items will
               also drop them when killed in combat. These items cannot be sold
               at shops.

  Agedfood   - Specifies that a food item increases its effectiveness as it is
               aged, rather than becoming spoiled. The $spoil attribute instead
               determines how long it takes for the $food count to increase by
               1/10th its original value.

  FracCost   - Makes a spell, technique, or skill require 1/x MP or EN per
               usage, where 'x' is the value evaluated in $cost. Players must
               have at least 1 MP or EN Point remaining to use the technique.

&& $level, Combat

$level <spell>=<level>

  Unlike spells, items in the Spell Database do not have a level setting when
  they are used from a player's inventory. This attribute sets the default
  level of <spell> when used as an item rather than casted as a spell. The
  maximum spell level is 10.
  
  If <level> is specified as -1, then the game will scan the player's Spell and
  Technique lists for matching items and use the highest level found.

&& $icon, Combat

$icon <spell>=<number>

  This value selects the icon to be shown to players when viewing an item
  with either the 'look' or 'inventory' commands. A valid icon <number> must be
  in the range from 1 to 65. Icons 1 through 31 are weapons and ammunition
  types, icons 32 through 43 are armor and relics, and items 44 up through 65
  are event items, tools, spells, and other item icon types. Setting $icon to
  -1 will create a blank icon, and using 0 will show the default icon based on
  the item's $type.

  Icons changed in this manner will always be gray in color. Use the $iconcolor
  attribute to override this.

  Note 1: This behavior will change as graphic icons are introduced.
  
  Note 2: The icons for spells and techniques can never be changed when shown
          in a player's inventory.

See also: $iconcolor

&& $iconcolor, Combat

$iconcolor <spell>=<number|color-codes>

  This value changes the color of the icon that is shown when viewing an item
  with either the 'look' or 'inventory' commands. <color> can either be a
  positive number or a color-code as used in the @color or $color attributes.
  Specifying 0 for <color> will show the default color for that icon.
  
  See 'help @color' for a list of possible color codes.

See also: @color, $color, $icon

&& $areaatk, Combat

$areaatk <spell>=<flags>

  Specifies the area attack range of a spell or technique. The range determines
  who and how many targets can get hit with the blast of a single attack or
  curative spell. The Area Attack consists of both an actual range of damage
  and flags that further select which types of enemies are chosen as targets.
  Enemies employing Artificial Intelligence use this to determine the possible
  targets of each attack while computing the probability for winning.
  
  <flags> is a combation of one Area from the first table below, followed by a
  space-separated list of zero or more Flags from the second table. If no flags
  are specified, then the area has a range of 0 and the spell will always
  target the caster regardless of what the caster types in.

  Area Range: (select only one of the following)

    Notarget - The default; no target is required for this spell. The spell
               will always reference its caster by default.
    Single   - A single target is the victim of the attack.
    Group    - Targets an entire group. A group consists of all enemies of the
               same species, or all players in the same +party.
    All      - Targets all objects that are the same object-type as the target
               specified by the caster. If no target is used, then this targets
               all enemies if the "Attack" flag is present or all allies if it
               is not.
    Everyone - Targets all creatures (with a combat status) in the room.
    Multi    - Allows the caster to specify the range of attack on the command-
               line. The caster can specify the name of a target for a Single
               attack, the name of a target prefixed with "*" for a Group
               attack (such as "*Dragonfly"), or the keyword "All". If the
               caster specifies no target, then "All" is automatically chosen.
               If the caster is confused, then an area type is chosen randomly.
    Domain   - Targets all players and enemies in the caster's current sector.
    Species  - Targets all enemies/players in the caster's sector matching the
               Group of the target specified on the command line.
    Global   - Targets all players currently logged into the game.

  Optional Flags: (zero or more of the following)

    Caster    - Instructs the game to target oneself, instead of an opponent,
                when no target is specified on the command-line. This is
                required for curative or non-ailment spells so that enemies
                casting from their Tactics lists will know to target and cure
                themselves instead of their opponents.
    Attack    - Designates the spell as an attack spell. Attack spells can
                never be targetted at oneself (unless set with the Reflect
                condition) and will always target an opponent in the room.
                Opponents will engage in battle against the caster if hit with
                an attack spell.
    Others    - Removes the specified target from the Area Range being
                attacked. When used with "Group" or "All" types, you can hit
                the target's group but not the target himself. For example,
                this flag can be used to cure all other allies in a caster's
                +party except for the caster himself.
    Auto      - Force the server to automatically select a target. This is
                used in conjunction with events which require the specified
                target to be something else, such as a message or a teleport
                destination. 
    Fumble    - Enable fumbling onto a different target as a random effect.
                See the 'help $fumbleatk' page for more information.
    Random    - Currently unimplemented.
    Noreflect - Keeps the spell from being reflected onto another player. The
                spell will be untouched by Bounce, Reflect, or reflective
                elemental conditions.
    Restrict  - Restricts target selection to either the player's allies or his
                opponents depending on whether the Caster flag is set.

  The following flags change the restrictions on which object-types can be used
  as valid targets. Restrictions are additive, in that players can match all of
  the types specified in the $areaatk. If none of the following flags are
  present, the game assumes both "Living" and "Wounded" are enabled.

  Object-Type Selection: (zero or more of the following)

    Living  - Allow living (non-wounded) players and enemies to be targetted.
    Wounded - Allow wounded players and enemies to be targetted.
    Room    - Allows the current room to be targetted. Makes 'here' the default
              target if nothing is specified on the command-line.
    Exit    - Allow any exit in the room, including non-combat ones, to be
              targetted.
    Thing   - Allow non-living objects in the room to be targetted.
    Item    - Allow inventory items or equipment to be targetted.

  The following flags can be used to restrict the types of valid targets when
  matching objects with a combat status. If none of the following are
  specified, then all three types are valid.

  Combat-Status Restriction: (zero or more of the following)

    Player   - Only target players.
    NPC      - Only target non-player characters and enemies.
    Familiar - Only target pets and player-owned familiars.

Examples:

  > $areaatk Refresh=Single Caster

  Specifies Refresh can strike only one target at a time, with that target
  defaulting to the Caster if otherwise not specified.

  > $areaatk Firebird=All Attack Fumble Noreflect
  > $fumbleatk Firebird=Everyone

  This spell will strike all opponents in the room with an attack spell,
  regardless if any Reflect condition exists on the opponents. Any enemies
  alive after the blast will engage in battle with the caster. If the spell
  fumbles, it will strike everyone in the room (see 'help $fumbleatk').

  > $areaatk Cheer=Group Caster Others Auto 

  This will cheer on a caster's +party members, targetting each of his allies
  except for the caster himself. The "Auto" flag is used so that the game will
  not parse whatever the caster gives for a target. In this manner, the spell
  always targets his allies and nobody else.

  > $areaatk Vine Growth=All Exit

  This spell will target all exits in the room. Most events require their
  targets to have a combat status for them to operate, so be sure to use an
  event that can work on inanimate exits.

See also: $fumbleatk

&& $fumbleatk, Combat

$fumbleatk <spell>=<area range>

  This attribute replaces the Area Range on a fumbled attack. A fumble occurs
  randomly 1 in 100+Intelligence times with physical attacks, or 1 in 100+
  Wisdom times with magic spells. When an attack fumbles, a random creature in
  the room becomes the target of the attack. Then, the $fumbleatk value
  determines the range of the attack, which is one of 9 Area Ranges listed in
  the first table in 'help $areaatk'. None of the optional flags can be used
  with $fumbleatk--those flags are instead carried over from $areaatk.

  The "Fumble" flag must be specified in $areaatk for fumbles to occur on a
  spell-by-spell basis. If the "Fumble" flag is set and $fumbleatk is not, the
  Area Range of a fumbled spell will default to "Notarget" and always strike
  the caster.

  The keyword "Fail" can be specified for <area range> only for the $fumbleatk
  attribute. If set and a fumble occurs, the spell will fizzle out rather than
  strike a random target in the room.

See also: $areaatk

&& $recharge, Combat

$recharge <spell>=<seconds>

  When set on spells or techniques, this specifies the period of time a player
  must wait before he can use or cast <spell> again. When <spell> is cast, the
  value xtime() + <seconds> is stored in a 32-bit integer on the caster in
  the Recharge Technique List for that spell. The player won't be able to cast
  the spell again until the current [xtime()] is at or greater than the
  recorded value.

  This attribute has no affect on inventory items.
  
  Note: In the case that both $recharge and $battles are set, $recharge takes
        precedence.

See also: $battles, xtime()

&& $battles, Combat

$battles <spell>=<amount>

  When set on spells or techniques, this specifies the number of enemies a
  player must defeat until he can use or cast <spell> again. When
  <spell> is cast, the number of battles defeated plus <amount> is stored in a
  32-bit integer on the caster in the Recharge Technique List for that spell.
  The player won't be able to cast the spell again until the number of defeated
  enemies (stored in the Enemies bitmap) is at or greater than the recorded
  value.

  This attribute has no affect on inventory items.

  Note: In the case that both $recharge and $battles are set, $recharge takes
        precedence.

See also: $recharge, @enemies

&& $component1, Combat

$component1 <spell>=<spell component>
$component2 <spell>=<spell component>
$component3 <spell>=<spell component>

  This attribute lists <spell component> as a requirement to be held in the
  caster's inventory in order to cast/perform <spell>. The spell component is
  consumed at the time of spell execution.

  $component2 and $component3 can also define additional spell components. All
  components must be held in the player's inventory to successfully cast the
  spell.

&
# You use up an Iron Nail.
# You use up 2 Eyeballs.
# You use up a Cross, a Stick, and a Clove of Garlic.

&& $component2, Combat

$component2 <spell>=<spell component>

  One of 3 possible components that are required for the successful casting of
  a spell or technique. See 'help $component1' for details.

&& $component3, Combat

$component3 <spell>=<spell component>

  One of 3 possible components that are required for the successful casting of
  a spell or technique. See 'help $component1' for details.

&& $applyitem, Combat

$applyitem <spell>=<effect item>

  This attribute specifies a particular item number that can be held in a
  player's inventory. The success rate of this spell or technique will increase
  by 100% if the $applyitem is currently held by the player as either equipped
  or in the player's inventory. The item will not be consumed when this spell
  is cast, as it only acts as a modifier.

See also: $applyequip, $applyskill

&& $applyequip, Combat

$applyequip <spell>=<equipment>

  This attribute specifies a particular equipment or template number that can
  be worn or wielded by a player. The success rate of this spell or technique
  will increase by 100% if the $applyequip item is currently equipped. The
  equipment will not be consumed when this spell is cast, as it only acts as a
  modifier.

See also: $applyitem, $applyskill

&& $applyskill, Combat

$applyskill <spell>=<skill>

  This attribute specifies that the success rate of the spell or technique
  can be further enhanced through the application of a skill. This value
  is set to the number of a skill that can be learned by a player. The
  success rate of this spell will increase up to 100% based on the player's
  mastery in that skill.

See also: $applyequip, $applyitem

&& $food, Combat

$food <spell>=<amount>

  Specifies the number of points this item will add to a player's Food count
  when eaten. It only has effect when the item's $type is Food. This attribute
  must be set for players to be able to 'eat' an item. The actual amount of
  food given decreases over time as the food spoils (but the $food value is
  left untouched). Spoilage is kept track on individual food items using the
  $spoilcount attribute. The maximum $food value that can be stored on an item
  is 1000.

  If a food item has 0 $food points, then the food item can only be dropped as
  bait for capturing or weakening monsters. Monsters are attracted to bait
  with varying likenesses depending on the $foodgroup set for that item.

See also: $foodgroup, $spoil, $spoilcount

&& $foodgroup, Combat

$foodgroup <spell>=<type>

  This attribute specifies the food group to which a Food-$typed item belongs.
  There are 11 food groups available, each which is set according to the most
  prominent ingredient, aroma, or taste in the food.
  
  These are the available food groups and their primary uses:

    Meat      - Cooked meats, roasts, and sandwiches.
    Vegetable - Freshly grown vegetables and salads.
    Fruit     - Fresh ripe fruits, juice drinks, nuts, and wines.
    Grain     - Bread and cereals.
    Seafood   - Fish, crustaceans, and other seafood.
    Dairy     - Milk and cheese products as the primary ingredient.
    Fungi     - Edible mushrooms.
    Sweet     - Pies, cakes, cookies, and other desserts.
    Slime     - Food made from slimes and jellies.
    Carrion   - Raw animal flesh and uncooked meats or fish.
    Rotten    - Rotten or otherwise spoiled foods.

  Besides being used as ingredients for cooking, monsters also have varying
  affinities for different food types. They can sometimes be drawn out from
  hiding or distracted from battle when food of a specific type is dropped in
  the room as bait.

  Monsters are attracted to bait based on their MeatEater/etc condition values,
  from 1 (smallest affinity) to 7 (largest). They go after bait more often when
  not engaged in combat. The following chart shows how often monsters will go
  after bait based on their condition value from 1 to 7, for both during battle
  and otherwise out hunting:

    In Battle:  1/20, 1/8, 1/6, 1/4, 1/3, 2/3, 1/1
    Hunting:     1/5, 1/4, 1/3, 2/3, 4/5, 1/1, 1/1

  The following 11 conditions are associated with the above food groups to
  set a monster's affinity level for each type of food, respectively:
  
    MeatEater, VegEater, FruitEater, GrainEater, FishEater, DairyEater,
    FungiEater, CandyEater, SlimeEater, FleshEater, SpoilEater.

  When baited, monsters currently in battle will be pacified for 3 rounds,
  giving players a chance to escape. Outside of battle, monsters will lose
  their aggression for 30 seconds and ignore any players entering or leaving
  the room. The $obait attribute will show for any monster who takes the bait.

See also: $obait, $food

&& MeatEater, Combat

MeatEater

  One of 11 conditions that determine a enemy's affinity to bait dropped in the
  room. This condition can be set from 1 to 7, with affinity increasing
  exponentially as the value approaches 7.
  
  MeatEater sets the enemy's affinity for cooked meats, roasts, burgers, and
  meat sandwiches.

See also: $foodgroup

&& VegEater, Combat

VegEater

  One of 11 conditions that determine a enemy's affinity to bait dropped in the
  room. This condition can be set from 1 to 7, with affinity increasing
  exponentially as the value approaches 7.
  
  VegEater sets the enemy's affinity for raw or cooked vegetables, salads,
  legumes, vegetable soups, sea plants, or other foods where vegetables are its
  primary ingredient.

See also: $foodgroup

&& FruitEater, Combat

FruitEater

  One of 11 conditions that determine a enemy's affinity to bait dropped in the
  room. This condition can be set from 1 to 7, with affinity increasing
  exponentially as the value approaches 7.
  
  FruitEater sets the enemy's affinity for fresh ripe fruits, berries, fruit
  juices, nuts, and wines.

See also: $foodgroup

&& GrainEater, Combat

GrainEater

  One of 11 conditions that determine a enemy's affinity to bait dropped in the
  room. This condition can be set from 1 to 7, with affinity increasing
  exponentially as the value approaches 7.
  
  GrainEater sets the enemy's affinity for wheat or grain-based foods, such as
  breads, cereals, pancakes, and pizzas.

See also: $foodgroup

&& $spoil, Combat

$spoil <spell>=<minutes>

  This attribute specifies the maximum amount of time in RL minutes a Food item
  is good until it goes stale and is no longer edible. As food becomes stale,
  the number of Food points gained when eaten approaches 0. When food is
  completely is stale or rotten, eating it can cause sickness or poisoning. A
  food item can change into another item when spoiled by setting the $transmute
  attribute. 

  The time given in <minutes> corresponds to outdoors or town-like areas. Food
  spoils faster in damp areas such as a dungeon or a swamp, so <minutes> should
  be only set as a term relative to other food products. For instance, iron
  rations should last much longer than milk. A food item is spoiled when its
  $spoilcount is equal to or greater than the $spoil value.

  Some items such as cheese or wines can increase potency over time. This is
  specified using the "Agedfood" option in the spell's $flags list. With that
  set, $spoil instead determines the number of minutes it takes for the $food
  count (calculated when eaten) to increase by 1/10th its original value.

See also: $food, $spoilcount, $transmute

&& $spoilcount, Combat

$spoilcount <spell>=<minutes>

  This attribute contains the current rate of spoiling for a particular food
  item, in minutes. All food begins with this count at 0 and slowly increases
  per minute until it reaches the value in the $spoil attribute. At that time,
  the food is either changed into another item (depending on $transmute), or it
  spoils, changing its $foodgroup to Rotten and offering 0 points when eaten.

See also: $food, $spoil, $transmute

&& $cost, Combat

$cost <spell>=<MP/EN Cost>

  This value sets the MP, EN, or Task Point cost required to successfully cast
  a spell, perform a technique, or make a wish, respectively. <MP/EN Cost> can
  be a [function()] that evaluates to the desired cost at cast time. Magic
  Power is spent if the spell's $type is "Magic" or "Prayer". Task Points
  are consumed if the $type is "Wish". Endurance is used in all other cases.
  
  $cost is not charged when the technique is used as an item from the player's
  inventory. Instead, the number of items in the inventory or the number of
  remaining $charges on a Wand will decrease by 1.

  If $cost is a random function that evaluates to either 0 or 1, such as if a
  spell or skill consumes fractions of MP/EN, consider also setting the
  "Require1" $flags option.

See also: $charges, $type

&& $chantrate, Combat

$chantrate <spell>=<delay>

  This attribute sets the duration it takes to chant a spell or perform a
  technique between when a player types the 'cast' or 'use' command and having
  those results trigger in combat. If this value is 0 or negative, then the
  delay is equal to the player's default Battle Speed when fighting or using
  items while being attacked. <delay> can be a [function()] that evaluates to a
  desired value at cast time.

  The <delay> is specified in tenths of seconds. For example, setting the delay
  to 48 means the spell will take 4.8 seconds to chant. A player's Chant Rate
  or Skill Rate are factored in as percentage modifiers on a spell's or
  technique's delay value, respectively.

See also: Chant Rate, Skill Rate

&& $mana, Combat

$mana <spell>=<value>

  This attribute specifies the current or remaining mana points in a combat
  item or Touchstone. This power can be extracted in the form of Magic Power
  via the 'draw' command, or recharged to the item via the Recharge Mana Event.

  $manaregen can be used to automatically regenerate or degenerate the
  remaining capacity once per minute. This value cannot go above that specified
  in $maxmana.

See also: Draw Points, $maxmana, $manaregen

&& $maxmana, Combat

$maxmana <spell>=<maximum capacity>

  This attribute sets the maximum amount of mana power that can be stored in a
  combat item, regarding the Draw and Mana Recharge events.

See also: Draw Points, Event Recharge Mana, $mana, $manaregen

&& $minmana, Combat

$minmana <spell>=<value>

  The minimum number of mana points that must be set on the object (in the
  $mana attribute) before a player can draw power from its reservoir. This
  gives an item time to regenerate lost energy so that the player can extract a
  sizable amount of power during the next use of the 'draw' command.

See also: Draw Points, $mana, $manarange

&& $manaregen, Combat

$manaregen <spell>=<value>

  This attribute sets the amount of mana points a combat item will regenerate
  (or degenerate) per minute. This value can be negative, 0, or positive.
  Combat items will regenerate even if they are lying in the room or held by a
  disconnected player.

See also: Draw Points, $mana

&& $manarange, Combat

$manarange <spell>=<percent>

  A specified percentage from 0 to 100 that determines the variance of amount
  of mana received during a successful 'draw' command. If set to 0, then the
  player draws exactly the amount of Magic Power he specified. If set to 75,
  then the actual amount drawn is between 25% and 175% of the amount specified.
  The amount drawn is evenly random between the low and high ranges.

  The variance calculation gets tricky when both $manarange and $manasurge are
  set. If the end result from the calculation falls below $manasurge, the
  positive amount of variance is reapplied on the $manasurge value.

  For example, one object can have a $manarange of 60 and a $manasurge of 100.
  If a player tries to draw 120 points, the +/- 60% variance can leave him with
  anywhere between 48 and 192 points (40% to 160%). If the end result is less
  than 100, then the combat system applies variance on $manasurge from 100% to
  160% and a shock message is sent to the player. This method can be used to
  hide the $manasurge cutoff value, creating a wildly unstable atmosphere for
  drawing Magic Power.

  See 'help @mana' for examples on rooms using both $manarange and $manasurge.

See also: @mana, $manasurge, Draw Points

&& $manasurge, Combat

$manasurge <spell>=<value>

  Specifies the minimum amount of Magic Power that can be extracted from a
  single successful 'draw' command by a player. Some touchstones can be
  configured with a high $manasurge value to give the effect of an
  uncontrollable amount of power contained in the item. With such items, only
  magic users with extremely low Magic Power compared to their Maximum MP will
  be able to harness the extra energy without becoming damaged by Mana Burn.

See also: Draw Points, $mana

&& $manacharge, Combat

$manacharge <spell>=<percent>

  The recharge rate, in percent, of how efficient a player's Magic Power can be
  converted into mana and stored on the combat item. A rate of 25% means that
  it takes 4 Magic Points from a player's MP to equal 1 mana point stored on
  the target object. Values greater than 100% are viewed by the system as 100%.

  This attribute is required to be set to allow players to use the Recharge
  Mana event on this object. A value of 0 effectively disables this object's
  ability to recharge mana (except for normal regeneration via $manaregen).

See also: Draw Points, Event Recharge Mana, $mana, $manaregen

&& Draw Points, Combat

Draw Points

  The Draw Point system is a very unique paradigm of gameplay that can be
  chosen by the game administrator for an interesting spin on standard RPG
  design. The basic premise is that Magic Power exists innately in the world,
  and players can only use this power by first extracting it from the lands
  and by various magical items that come from the region.

  In TinyMare, rooms and combat items can be configured individually to hold a
  maximum capacity of Magic Power. Players can extract such power at will from
  these objects, or players can opt to infuse power back into them. Mana
  sources can be set to regenerate or degenerate power over time. The system
  can even be configured so players take damage if they try to draw too much
  power from a single source than they can handle.

  On combat items, 7 attributes govern how Draw Points behave:

    $mana - The current or remaining capacity of a Draw Point. This value
            changes over time due to regeneration or when players extract or
            infuse power using the draw point. When this value falls to 0,
            either due to drawing or automatically via degeneration, the item
            can disappear or switch templates based on the $transmute variable.

    $maxmana - The maximum capacity of Mana Points that can be stored in this
               specific Draw Point.

    $minmana - A number of Magic Points that the mana source must have before
               a player can draw more power from its reservoir. This allows a
               region to regain some lost energy over normal regeneration so
               that when players next successfully draw from the location, they
               will get a moderate amount of power back.

    $manaregen - A value indicating the change in this Draw Point's current
                 Magic Power per minute. This value can be negative, 0, or
                 positive.

    $manarange - A number in percent from 0 to 100 that determines the variance
                 of Magic Power received during a draw. If set to 0, then the
                 player draws exactly the amount of Magic Power he specified.
                 If set to 50, then the actual amount drawn is between 50% and
                 150% of the amount specified. If set to 100, the amount drawn
                 is between 0% and 200% of that specified. The default is 0.

    $manasurge - The minimum amount of Magic Power that a single draw from the
                 Draw Point will produce for a player. Some Draw Points can be
                 configured with this value high to indicate an overflowing
                 surge of power stored in the region. Players with near-maximum
                 Magic Power can be easily taken off guard, drawing more than
                 they intentionally wanted.

    $manacharge - A recharge rate, in percent, describing the ratio of power
                  successfully charged on the Draw Point per each Magic Point
                  transferred by the Recharge Mana event. A $manacharge of 25%
                  means that players require 4 MP to charge 1 Magic Point on
                  the Draw Point. A value of 0 (default) disables this object's
                  ability to recharge mana. Values greater than 100% are
                  assumed to be 100%.
  
  On rooms or zones, the above variables can be defined using a single @mana
  attribute containing each Attribute=Value pair separated by spaces. If a zone
  is set with @mana information, each room in the zone has its own capacity
  from which to draw. See 'help @mana' for syntax and room-style examples.

  A room's current mana value is stored via the Room Condition "Drawpoint". Use
  @setcond <room#>=Drawpoint,<Amount> to manually change the value.

  For combat items, the $maxmana value must be set in order to allow players to
  draw from the item. The $transmute attribute dictates what happens to the
  item when its Magic Power is fully depleted.

Touchstones:

  While combat items must be equipped in order to draw mana from them, a
  certain class of items need only be in a player's inventory to take advantage
  of their properties. An item can have its $type attribute set to "Touchstone"
  to allow players to extract and infuse Magic while the item is still in his
  inventory.

Mana Burn:

  If a player draws an amount of Magic Power great enough to exceed his Maximum
  MP, then he will be damaged with the effect known as Mana Burn. Mana Burn is
  a bane to players who seek the most unstable sources of energy for a quick
  fix to their low remaining Magic Power.
  
  Based on the type of system selected via the DRAW_SYSTEM configuration
  variable, Mana Burn can affect a player's Current HP (system 1) or Maximum HP
  (system 2). DRAW_DAMAGE determines how much damage a player receives for
  every magic point drawn over his Maximum MP, in percent.

See also: Event Recharge Mana, @mana, $mana, $manacharge, $manarange,
          $manaregen, $manasurge, $maxmana, $minmana, $transmute

&& Pyramid Curve, Combat

Pyramid Curve

  Most of the functions that calculate damage use a random curve called the
  Pyramidal Damage Curve. The curve is named such because the frequency of
  values randomly appearing are in the shape of a pyramid. This curve provides
  a means of returning a value between a range of numbers, from "lo" to "hi"
  inclusive, with values closer to the center of the range occurring more
  frequently than those closer to the edges. The rate of change in frequency
  from the edges to the center is linear and allows for random results falling
  near the "lo" or "hi" edges to have a much better chance than a Normal Curve.

  The formula used for the curve resembles a process identical to summing two
  dice rolls together. Itself consists of summing 2 random numbers equal to
  half of the size of the range together, and then adding the lower bound of
  the range. Below, the function "rand(n)" is defined as returning a random
  number from 0 to n-1. To help visualize this curve, a table showing the
  linear increase and decrease of frequency is presented for all values for a
  standard 2-dice roll (where the range is lo=2 and hi=12).

  Value := (rand(hi-lo+1)+rand(hi-lo)+1)/2 + lo.

        Frequency of
         occurrence:

           6:36                   -
           5:36                -     -
           4:36             -           -
           3:36          -                 -
           2:36       -                       -
           1:36    -                             -
                   2  3  4  5  6  7  8  9 10 11 12   :Resulting Value

See also: Event Attack

&& Status Attributes, Combat

Status Attributes

    0 Hit Points        MAXHP       32 Current HP        HP
    1 Magic Power       MAXMP       33 Current MP        MP
    2 Endurance         MAXEN       34 Current EN        EN
    3 Strength          STR         35 Level             LV
    4 Vitality          VIT         36 Steps             STEPS
    5 Intelligence      INT         37 Sessions          SESS
    6 Wisdom            WIS         38 Age               AGE
    7 Agility           AGL         39 Money             GP
    8 Dexterity         DEX         40 Vault             VAULT
    9 Luck              LUCK        41 Food              FOOD
   10 Willpower         WILL        42 Task Points       TASK
   11 Critical Rate     CRIT        43 Carry Weight      WGT
   12 Reprisal Rate     REPR        44 Alignment         ALIGN
   13 Experience Rate   EXPR        45 Enemies Defeated  KILLS
   14 Chant Rate        CHANT       46 Escapes           ESC
   15 Skill Rate        SKILL       47 Deaths            DIES
   16 Attack Power      ATK         48 Inn Stays         INN
   17 Defense Power     DEF         49 Current IP        IP
   18 Magic Force       MATK        50 Drain %           DRAIN
   19 Magic Resist      MDEF        51 Current Moves     MOVES
   20 Battle Speed      VIGOR       52 Maximum Moves     MAXMOVES
   21 Hit %             HIT         53 # Attacks         ATKS
   22 Evade %           EVD         54 Divisor           DIVISOR
   23 Magic Hit %       MHIT        55 Stored Energy     ENERGY
   24 Magic Evade %     MEVD        56 MP Charge %       MPRATE
   25 Fumble Rate       FUMBLE      57 EN Charge %       ENRATE
   26 Regeneration      REGEN
   27 HP Loss           HPLOSS
   28 MP Loss           MPLOSS
   29 EN Loss           ENLOSS
   30 # Targets         NTARGETS
   31 Spell Level       SPLV

&& Spell Messages, Combat

Spell Messages

  
&& Event Attack, Combat

1. Attack

  "Attack" is the primary event of the combat system, allowing a technique to
  inflict (or heal) damage points on a target's Health, Magic Power, or other
  status variable. A combat equation specifies how the damage is to be
  calculated from the caster's stats and determines which stats the target uses
  to defend against the attack.

  The first argument [Arg0] specifies an attack type, plus a space-separated
  list of flags that can be used to modify the type of damage, determine if
  weapons are used in the attack, and enable the enemy to defend using its
  armor. The next argument, [Arg1], is a space-separated list of Elements that
  compose the type of attack, such as Fire or Water. Some enemies can be weak
  to certain elements taking more damage, while others can be strong and take
  no damage at all. The remaining arguments, [Arg2] and up, are in the form
  Option=Value and each can be specified to enhance the attack or focus on
  specific targets.

Syntax:

  Arguments: <Attack Type+Flags>,<Elements>,<Event Options>,...

  [Arg0] Attack Types: (one of the following)
    Normal   - Damage is calculated solely by the Damage= and Defense= event
               options. Both equations evaluate to 0 if omitted.
    Physical - A physical attack consisting of the caster's Attack Power and
               the target's Defense Power.
    Magical  - A magical attack consisting of the caster's Magic Force and the
               target's Magic Resistance.
    Curative - A magical healing that becomes more powerful as the caster's
               Wisdom increases. If Cure magic harms a creature (such as an
               Undead), the enemy defends with its Magic Resistance.
    Breath   - An attack that covers a wide range of area around the target.
               Only the target's shields and armor will add to the defense of a
               breath attack whose strength is proportional to the caster's HP.
    Psionic  - A mental attack that harms the mind of the target. Willpower is
               used for both the default Damage= and Defense= equations.

    Note: Specifying an equation for Damage= or Defense= power will override
          one of the predefined values below. If no Attack Type is specified,
          the event defaults to "Normal".

    Normal   - Damage=0         Defense=0
    Physical - Damage=ATK       Defense=DEF
    Magical  - Damage=MATK      Defense=MDEF
    Curative - Damage=WIS/2     Defense=MDEF
    Breath   - Damage=HP        Defense=DEF-VIT
    Psionic  - Damage=WILL      Defense=WILL

    Other Attack Types include Status Attacks and Condition Attacks, which are
    described in the page 'help Status Attacks'.

  [Arg0] Flags: (add zero or more of the following)

  Weapon - Apply weapon attributes.
    This flag specifies that the player's weapon will be used in an attack
    against the target. All conditions and elements set on the weapon will be
    applied to the attack each round, and the target's saving throw will
    determine the weaknesses and strengths to the element used or if the
    condition setting is successful.

  DamageEQ - Damage equipment.
    This flag specifies that the equipment worn by the target and the weapon
    wielded by the attacker should become damaged under the force of the
    attack. The amount of damage depends on how well the target's armor can
    deflect the blow compared to the strength of the attacker's swing. Weapons
    and armor of lower quality and weaker material composition will degrade
    faster than those made from durable or tempered metals.

    Note that the attacker's weapon will only be damaged if the "Weapon" flag
    is also selected.

  Critical - Enable a critical hit.
    This flag allows for an extra roll using the attacker's Critical Rate out
    of 256. If the roll succeeds, the attack becomes a Critical Hit and the
    enemy's defense is reduced to 0. The Critical Rate is never checked during
    an attack that cures its target.

  Random - Random damage.
    This flag extends the lower bound "lo" of the Damage= equation to zero,
    regardless of all other range calculations. The "hi" end of the range is
    set to the original amount of damage, X. What results is a random number
    between 0 and X. If used with the "Pyramid" flag (see below), values closer
    to 1/2 X will occur more often than 0 and X.

  Pyramid - Pyramid curve.
    Apply the Pyramid Curve to the calculated damage value before the target's
    defense is subtracted. The pyramid curve picks a random number between
    the possible low and high ranges specified in the Damage= equation. The
    randomness of the number generated is weighted more towards the middle of
    the range than the edges.

    If the Damage= equation does not specify a range but instead a fixed value,
    then the range grows to what is specified in the configuration variable
    PYRAMID_RANGE (in percent). The "hi" value remains at X (the original
    damage value), but the "lo" value is set to PYRAMID_RANGE % of X.
    
    See 'help Pyramid Curve' for details on how the random value is picked.

  Invert - Inverted pyramid curve.
    This flag inverts the frequency of occurrence of the values in the Pyramid
    curve, such that values closer to the "lo" and "hi" ends of the range will
    occur more often than values in the exact center. This flag only has
    meaning when used in conjunction with the "Pyramid" flag mentioned above.

  Center - Center range around base value.
    This flag only has effect when a fixed value (no range) is specified in the
    Damage= equation. When set, it grows the range to what is specified in the
    configuration variable PYRAMID_RANGE (in percent), with X being the direct
    center of the range. What results is that "lo" becomes X - (1/2 Pyramid %)
    and "hi" becomes X + (1/2 Pyramid %), and a random number is chosen between
    "lo" and "hi".
    
    This flag is most often used with the "Pyramid" flag. This makes the
    frequency of the random values centered more often around the original
    value X than at "lo" and "hi". It allows for techniques to aim at a certain
    damage value with reasonable success, giving rare potential for big misses.
    
  Divide - Divide damage by number of targets.
    In some cases, multiple players or enemies can be the targets of a single
    technique or spell, each receiving the same amount of damage specified by
    the Damage= equation. As a result, such a spell becomes much more powerful
    as the caster can inflict more total damage with a single cast when more
    enemies are targetted.
    
    This flag alleviates the problem by decreasing the amount of damage as the
    number of targets increases. The resulting damage is not completely divided
    by the number of targets, rather instead approaches a lower limit of 1/3
    total damage when an infinite number of targets are selected. Combat uses
    the following function to determine the damage for all targets, where X is
    the original amount of damage and 'n' is the number of targets:

        Damage = X/3 + X*2/(3*n)
    
  Nodivisor - No disivor calculation.
    This flag allows the bypass of the Divisor calculation, which an enemy
    could use to heavily restrict the amount of damage after all defense has
    been applied. Only attacks that can never be protected against should have
    this flag set. This flag is automatically in effect if the attack cures,
    rather than damages, its target.

  Limit - Limit damage beyond capacity.
    This flag restricts the amount of damage received by the target to be no
    greater than the target's current Hit Points (or Magic Power, etc). In
    combat, it serves two purposes. First, this flag can be used for display
    purposes on specialized attacks or curative spells. An attack with this
    flag set will never print a damage value greater than the amount of HP
    remaining on the target. Similarly, with a curative spell, the value shown
    will never be higher than the difference between MaxHP and HP. It has the
    effect of giving players some insight as to the exact HP/MP/EN of enemies
    without specifically analyzing their status.
    
    Second, this flag is important when creating Drain elemental spells or
    weapon attacks. When draining, this flag corresponds to the caster's HP and
    MaxHP instead of the target's. With this flag present, victims of drain
    spells are protected from losing any HP if the caster's Hit Points are
    already full. Otherwise, victims lose HP regardless of the caster's health.
    In either case, the caster cannot gain any more HP than what remains on the
    victim.
    
  Decay - Damage depends on target's current status modifications.
    Used for Status Attacks, this flag reduces the "Damage=" equation based on
    the difference of the target's current stat value versus his original base
    value. Over time, successive spell-casting will taper the actual lowering
    or raising of a stat to 0, conforming to a simple 50% rate of decay as the
    difference becomes larger. See 'help Status Attacks' for more details.

  Lefthand - Allow attacking with both hands.
    This flag allows the technique to schedule an additional attack per round
    if the player has a weapon in his left hand. The additional attack triggers
    shortly after the first attack, during which the weapon in the player's
    left hand will be used to calculate resulting damage, elements, and status
    condition effects. The event is not over until both attacks are executed.
    The delay between right- and left-hand attacks is 1/10th the attacker's
    battle speed.

    Note: A player who masters the martial art "Lefthand Fighting" can attack
    with both hands when no weapons are equipped.

  Multiple - Allow multiple attacks.
    If this flag is set, the event will queue a number of attacks equal to the
    player stat [# Attacks] with a time lapse of 1/5th the player's battle
    speed between attacks. The event ends when all attacks are executed, or
    when the enemy becomes wounded or dies. If this flag is used with
    "Lefthand" and the player has two weapons equipped, then the delay between
    attacks is halved.
    
    Here is an example of the time lapse in a battle round where the player has
    a weapon in both hands and 2 attacks:

        1. Player types 'fight'.
        2. (5.0 second wait, or battle speed)
        3. Right-hand attack #1.
        4. (0.5 second wait, 1/10th speed)
        5. Left-hand attack #1.
        6. (0.5 second wait)
        7. Right-hand attack #2.
        8. (0.5 second wait)
        9. Left-hand attack #2.
       10. (End of round; 5.0 second wait)
       11. Next event...

  FixedHit - Hits its target with a fixed success rate.
    Makes the attack strike its target at a fixed success rate, based solely on
    a value from 0 to 100 determined by the "Hit=" combat equation. The enemy's
    Evade rate is completely bypassed, and no Evade % adjustments on armor can
    deflect the shot. If no "Hit=" equation is present, then the attack always
    succeeds.
    
    Note that this flag does not change the defense rating of a target's armor,
    as some attacks can still Ping if the damage is too weak.

  Natural - Signify a natural occurrence with no source of attack.
    Attacks marked Natural will have damage displayed to the room as if it had
    originated from the target himself and not from the attacker. Such attacks
    are indicative of damage due to a toxic atmosphere or drowning, internal
    bleeding, or damage caused by the sun, lava, or walking on sacred grounds.
    Targets will not automatically engage in battle when hit with Natural
    attacks.

  Quiet - Suppress damage message.
    Hide any amount of damage caused by a specific event. No message will be
    displayed to any player in the room that the target has lost or gained any
    status modification. This is usually used for attacks that have a secret
    event in addition to a normal attack.

  Nocheck - Don't check if target's HP/MP/EN are already full.
    This flag surpasses any checking to determine if the target's Health, Magic
    Power, or Endurance is already full when using a curative spell or item. By
    default, curative spells and items cannot be used on single targets when
    there will be no effect. Using items during battle will check the target's
    stat immediately when used. In contrast, spells, whose targets are not
    determined until the time of spell execution, will only check the stat
    after the chanting has completed, and no Magic Power will be consumed.
    Checking is only performed on the first event slot in a spell if it is an
    Attack event, so this flag is unneeded for secondary events.

  Nouncon - Bypass unconsciousness when damaging target.
    This flag is only used with damaging attacks to disallow the target to go
    Unconscious when it is hit. Targets whose HP drop to 0 will immediately die
    from this attack.

  Delay - Delay the next battle move after this attack.
    This flag can be used in techniques such as "Quick Hit" where there is no
    chanting time. The attack executes swiftly, however, the player's next move
    will be delayed by 1 additional round.

  Longrange - Enable physical attacks against enemies out of range.
    This flag enables the ability to strike a target that is out of reach, such
    as enemies set with the Flying condition. Only physical attacks need this
    flag set, since magic spells ($type = Magic) can target any enemy in the
    room. Some weapon types such as Bows or Slingshots automatically inherit
    this flag.

  Randelem - Attacks with a random element from the given list.
    This attacks each target with a random magic elemental from those specified
    in [Arg1]. Elementals not affected are Cure, Drain, Bludgeon, Pierce, and
    Slash, as well as any elements derived from an equipped weapon.

  Taper - Taper damage to each successive enemy in an attack.
    Used when targetting groups of enemies, this flag will decrease the amount
    of damage inflicted on additional monsters hit by 2/7th, successively. This
    damage is adjusted prior to defense or armor calculations and is applied
    only when the strike is successful.

  The default "Fight" technique (Spell 0) is given using the following flags:

  > $event1 0=
  >   Attack:Physical+Weapon DamageEQ Pyramid Lefthand Multiple Critical

  [Arg1] Elements:
    This argument contains a space-separated list of elements that constitute
    the type of attack the technique inflicts. A technique usually has zero or
    one type of element associated with the damage. Enemies can be weak,
    strong, or immune to certain elements, therefore increasing, decreasing, or
    nullifying the damage inflicted. Enemies can also absorb elemental attacks,
    thereby restoring Hit Points when others would have been damaged, or
    reflect attacks, thereby targetting the spell back at the caster's party.

    The effects of elements vary when they are mixed. With magical elements,
    the percentages of damage are averaged for all elements used by the spell.
    For physical elements (Bludgeon, Pierce, and Slash), the worst damage takes
    precedence. If both magical and physical elements are present in the spell,
    then the worse of both element groups takes precedence. See 'help Elements'
    for more details.

    If one or more element types (physical or magical) are specified for a
    technique, those types override any elements that are defined on a player's
    weapon--even when the "Weapon" attack flag is specified. If no elements are
    to be defined, place a "0" in for this argument before specifying any event
    options. Some families of enemies, such as Ghosts, can only be harmed when
    at least one magical element is listed.

Combat Equations:

  Two equations can be specified as options for every Attack event. These
  equations are calculated on the fly during the event and can change based on
  the status variables of both the caster and the target. The Damage= equation
  is used to override the default damage for the particular attack type, and
  the Defense= equation is used to override the stats the target uses to defend
  from the attack. Both are essential to defining highly stylized spells and
  skills for combat.

  As with all event options (described below), combat equations are appended to
  the last normal argument of the @addevent command, separated with a comma.
  The equation can contain standard mathematical operators, parentheses, status
  variables, percents, and functions. A special symbol, the Range Specifier
  '|', can be used to designate an allowable range between two numbers (Damage
  equation only). It has the lowest precedence of the operators, so care with
  parentheses is necessary to establish the right equation.

  The available functions are:
    Rand(n)      - Returns a random number from 0 to n-1.
    Sqrt(n)      - Returns the square root of n.
    Gamble(n)    - Returns a special casino-style lucky number, where 'n' is 0
                   through 10. 'n' here is normally specified as SPLV-1 to
                   calculate damage power. The values Gamble() returns are:

         111, 333, 555, 777, 999, 1111, 3333, 5555, 7777, 9999, 12345

    Cond(c)      - Returns the value of a player's condition c. 'c' must be a
                   condition name or number and cannot be an equation.
    Econd(c)     - Returns the value of an enemy's condition c. 'c' must be a
                   condition name or number and cannot be an equation.
    Min(x,y)     - Returns the lower of the two numbers 'x' and 'y'.
    Max(x,y)     - Returns the higher of the two numbers 'x' and 'y'.
    Pyramid(x,y) - Returns a random number between 'x' and 'y', weighted
                   towards the center.
    Abs(x)       - Returns the absolute value of 'x'.

  Each combat equation can use both the caster's and target's status variables
  to calculate the resulting value. Variables are specified as a short-hand 2
  to 7 letter word that describes the stat. Type 'help Status Attributes' for a
  list of status abbreviations that can be used.
  
  A status variable can be prefixed with an "E." to designate the opposite
  target's stat rather than the caster's. Other prefixes, listed below, can be
  used separately or after the "E." to find other values associated with a
  specific stat. For example, you can use "E.BASE.<stat>" to return an enemy's
  bitmapped status value.
  
    BASE     - Returns the base stat without any equipment or status changes.
    NOEQ     - Returns the stat value before equipment modifications.
    NOMOD    - Returns the stat value without adding in any status changes.
    
  Here are some examples of general combat equations that use a player's
  status, along with their meanings:

  ATK*150%      - A value equal to 1.5 times the player's Attack Power stat.
                  Since decimals and fractions cannot be represented, values
                  must be multiplied by a percentage instead.
  ATK*3/2       - Effectively the same as the above. With integers, always
                  multiply before dividing because remainders are dropped.
  E.HP/4        - Returns the enemy's current Hit Points value divided by 4. If
                  this was an attack, the enemy would lose 1/4th of its HP.
  INT-BASE.INT  - Returns the amount of Intelligence stat increase that the
                  caster's equipment or other temporary spells provide.
  Rand(MAXHP)   - The value is equal to a random number between 0 and the
                  player's Maximum Hit Points - 1.

  Note: The game simplifies equations as they are entered into the event. It is
        normal for parentheses to disappear and capitalization to change upon
        examining the spell.

Event Options:

  There are many Attack event options that can be used to alter the outcome
  of the technique. Each option is processed in order of appearance, however
  with the exception of "Condition" and "Remedy", only one of each option may
  be specified per event. The available options are:

  Damage=<Equation>
    This option specifies the equation to use for calculating a technique's
    Damage Potential against the enemy (either harmful or curative). Stats are
    relative to the caster versus the enemy target (see examples below).

  Defense=<Equation>
    This option calculates the amount of defense points an enemy gets against
    the attack. Status attributes are based on the target's point of view,
    therefore "Defense=DEF" refers to the target's defense power and not the
    attacker's. Likewise, "Defense=E.HP" refers to the attacker's HP value.

  Duration=<Equation>
    This option specifies a duration of time for a special status attack or
    condition ailment to last, based on the caster's status. For status
    attacks, the Attack Type "ST:Duration" must be used. Two or more events are
    necessary to inflict multiple conditions with different durations. See
    'help Status Attacks' for more details.

  Charges=<Equation>
    This option sets the number of times a status modifier can be retrieved
    from the target until it is automatically removed by the combat system.
    This equation is only required when the Attack Types "ST:Charges" or
    "ST:Round" are used. See 'help Status Attacks' for more details.
    
  Drain=<Equation>
    This option specifies the percentage of damage a Drain attack will restore
    towards the caster. This value defaults to 100 if left unspecified. It is
    multiplied together with the caster's Drain bitmap variable before being
    applied as a damage modifier. This equation only has effect when the
    "Drain" element is used in [Arg1].

  Hit=<Equation>
    This option allows the programmer to specify a per-event Hit % adjustment
    on a single attack. This value can be positive or negative and represents
    a top-level percentage added to the caster's Hit % before any Hit/Miss
    calculations take place. If the "Fixedhit" damage type is used in [Arg0],
    then this equation must evaluate to a constant Hit % rate from 0 to 100. If
    "Fixedhit" is specified and this equation is omitted, then a 100% Hit rate
    is presumed.

  Stat=<Stat Name>:<Limit>
    This option instructs the Attack event to target a specific status variable
    on the enemy other than HP. <Stat Name> refers to one of the shorthand
    status labels found on the 'help Status Attributes' page and cannot be
    prefixed with "E." or "NOEQ.". The most common attacks use HP, MP, or EN,
    but any modifyable status variable can be specified for a permanent status
    increase or decrease.

    Using one of 6 special Attack Types as the base value of [Arg0], you can
    specify the attack to have a temporary instead of permanent status change.
    Temporary status modifiers apply a positive or negative adjustment to a
    player's base stat, cumulatively. The Attack Type used determines when
    these adjustments wear off. The possible Attack Types are "ST:Inn",
    "ST:Duration", "ST:Room", "ST:Gradual", "ST:Battle", "ST:Charges", and
    "ST:Round", and are further described in the page 'help Status Attacks'.

    <Limit> is an optional value that limits how many points above or below a
    temporary status change can be increased or decreased from its original
    base value (during successive technique uses). Any attempts to change the
    stat beyond this limit will result in a Miss. <Limit> can be followed by a
    % sign to calculate a percent of the base stat rather than actual points.
    If this value is omitted, then no upper limit is set.

  Condition=<Condition>:<Value>:<Level>:<Rate>:<Charges>
    This option allows the attack event to inflict a condition on its target.
    <Condition> can be any number of ailments, special effects, or race/relic
    abilities that is to be applied, separated by + symbols if more than one is
    listed. For each harmful condition, the target is subject to a saving throw
    to withstand the condition's effects. If the saving throw fails, the target
    gets set with the condition and the event succeeds.
    
    The other four arguments are optional combat equations that can be listed
    per Condition= option. <Value> corresponds to the number of points to add
    to the target's current condition (a 1 is assumed if <Value> is zero or
    negative). <Level> sets the saving throw level for inflicting a condition,
    either harmful or protective, on the target (if not specified, the level of
    the spell being cast is used by default). <Rate> is a random rate out of
    1000 that determines how often the listed conditions (chosen individually)
    are applied per event execution. <Charges> specifies how many times the
    condition can be checked by the combat system until it expires (only useful
    when the "Charges" condition type is selected).
    
    Multiple Condition= and Remedy= statements (see below) can be included in a
    single attack event to set or reset several conditions with different 
    arguments for Value, Level, Rate, and Charges. The event succeeds if any
    condition in the list is successful. If the only purpose of the attack is
    to attempt a condition change, then use the "Ailment" attack flag in [Arg0]
    to suppress damaging HP, MP, or EN. See the page 'help Status Attacks' for
    more information and examples on setting conditions.

  Remedy=<Condition>:<Value>:<Level>:<Rate>
    Same as above, but attempts to remove a temporary condition set on a the
    target. Saving throws apply if the condition you are trying to remove is
    not an ailment. <Value> is the number of points to remove from the target's
    condition, or if less than 1, removes the condition completely.

Target Selection Options:

  In the following options, <Percent> refers to a percentage that is multiplied
  to the result of the "Damage=" equation (before Defense is subtracted). More
  than one option can be specified to match different types of conditions,
  races, and so on. The percentages are not cumulative, and only the last
  matching option will have its percentage applied to the Damage= equation.

  <Percent> can also hold special values. If "0" is used, then the resulting
  damage will always print a white zero in the room indicating the attack
  successfully hit but scored no damage to the target. If "Miss" is used, then
  the attack will always miss and no item consumption takes place. If "Consume"
  is used, then the attack misses but any used items are consumed from the
  player's inventory. The spell's $miss and $omiss attributes attributes will
  be shown to players during a "Miss" or "Consume".
    
  Percent=<Percent>
    This option specifies a <Percent> multiplier that always matches
    regardless of the target being attacked. Therefore it is only useful when
    given prior to one of the following options:

  Hascond=<Type>:<Percent>
  Hascond=!<Type>:<Percent>
    Multiplies the damage by <Percent> percent if the target has (or does not
    have) the specified condition <Type>. For example, "Hascond=Flight:150%"
    means to do 150% damage on all creatures currently in Flight.

  Race=<Type>:<Percent>
  Race=!<Type>:<Percent>
    Multiplies the damage by <Percent> percent if the target is (or is not) a
    member of race <Type>. This option is NOT checked on non-players.

  Guild=<Type>:<Percent>
  Guild=!<Type>:<Percent>
    Multiplies the damage by <Percent> percent if the target is (or is not) a
    member of guild <Type>, including past specialties learned in this guild.
    This option is NOT checked on non-players.

  Family=<Type>:<Percent>
  Family=!<Type>:<Percent> 
    Multiplies the damage by <Percent> percent if the target belongs (or does
    not belong) to the genus family <Type>. For example, "Family=Giant:200"
    means to deliver 200% damage on Giants and 100% on all other targets.

  Gender=Male:<Percent>
  Gender=Female:<Percent>
    Multiplies the damage by <Percent> percent if the target's gender matches
    the type specified. This option is NOT checked on non-players.

  LvMultiple=<Level>:<Percent>
  LvMultiple=!<Level>:<Percent>
    Multiplies the damage by <Percent> percent only if the target's level (LV)
    matches (or does not match) the <Level> multiple specified. For example,
    the option "LvMultiple=!3:Miss" will only target enemies whose levels are a
    multiple of 3.

  Sector=<Type>:<Percent>
  Sector=!<Type>:<Percent>
    Multiplies the damage by <Percent> percent only if the target is (or is
    not) in the specified sector <Type>. This is useful mainly with global
    attacks that hit players in multiple areas of the world.

  Virtue=<Value>:<Percent>
  Virtue=!<Value>:<Percent>
    Multiplies the damage by <Percent> percent only if the target's Alignment
    is (or is not) at least <Value> or greater. <Value> must be a number within
    the range -2000 to +2000.

Caption Variables:

  The following results are stored incrementally in environment variables %1
  through %9 for each combat equation listed in the entire spell (across
  multiple events). Only specified equations are recorded in a variable. For
  instance, if both Damage= and Duration= equations were given, they would
  correspond to %1 and %2 per the order in the table below. More results in
  additional events will begin at %3, and so on.

  All combat equation results are displayed in "Value" or "Lo-Hi" format,
  calculated with both Caster and Target as the person viewing the spell. If
  the Damage= equation ends in a percentage, a % is displayed following the
  value. Note that [v(1)] instead of %1 must be used to retrieve a string
  containing the % symbol.

  Equations are reported in the order:

    Damage, Defense, Duration, Charges, Drain, Hit.

Examples:

  > $event1 Medical Herb=Attack:Normal+Pyramid,Cure,Damage=20|35

  The simple command above configures a curative item, the Medical Herb, to
  restore the Hit Points of its target. It is a "Normal" attack, which does not
  add any Attack or Defense Power to the result calculated. The element present
  is "Cure", making the target regain Hit Points from the attack instead of
  lose them. The Damage equation specifies a solid range between 20-35 HP to be
  regained, and the "Pyramid" flag tells the system to make values closer to 27
  appear more frequent than 20 and 35.

  > $event1 Blaze=Attack:Magical+Pyramid Divide,Fire,
  >   Damage=MATK+(5|15)+SPLV*(5|10)

  The above command configures a Blaze spell to be a magical attack with the
  element attribute of Fire. Its base attack power is the caster's Magic Force
  (MATK) plus the range 5 to 15. The spell's damage range also increases by 5
  to 10 per spell level. Therefore, if the player's Magic Force is 12, the
  spell will inflict 17-32 damage points on Level 0, 22-37 damage points on
  Level 1, and so on. If this spell targets multiple enemies, the "Divide" flag
  will decrease the amount of total damage dealt by a small fraction. Because
  of the "Magical" attack type, the target's Magic Resistance implicitly
  defends against the attack.

  > $event1 Holy Water=Attack:Nodivisor,Holy,Damage=E.MAXHP/14+1,
  >   Family=!Undead:Consume

  This event is suitable for using Holy Water on an undead enemy. The attack
  type is by default "Normal", which has no specified Attack or Defense power.
  The "Nodivisor" flag is used, which means that the damage cuts through any
  special defenses set on the enemy. The damage delivered is equal to the
  target's Maximum Hit Points divided by 14, plus 1. The catch is, the item
  will damage the target only if it is Undead (otherwise, the item will miss
  and be consumed). Because most Undead are susceptible to Holy elementals
  (thereby receiving double damage), it will take roughly 7 uses of Holy Water
  to completely annihilate an Undead enemy. Since rounding issues are present,
  it is a good idea to use +1 whenever you deliver damage based on a fraction
  of the enemy's MaxHP.

  > $event1 Dragondive=Attack:Physical+Weapon DamageEQ Pyramid Random Invert,
  >   Pierce,Damage=ATK*200%,Condition=Flight:150%,Family=Dragon:200%

  This spell is similar to "Fight" in that it uses normal Attack Power and
  Defense Power, but the differences stop there. The "Pyramid Random Invert"
  flags, coupled with "Damage=ATK*200%", indicate that the resulting damage is
  equal to a random number between 0 and twice the attack power, with a higher
  frequency towards the "lo" and "hi" limits of the range. This describes the
  skill's tendency to either graze its opponent or deliver a critical blow. On
  top of that, this skill will hit flying enemies for 1.5x as much damage, and
  dragons for 2x as much damage (regardless if they are flying). Slimes and
  other soft-skinned creatures may have an additional susceptibility to the
  Pierce elemental.

  > $event1 Exploder=Attack:Magical+DamageEQ Pyramid Divide,Fire,Damage=HP
  > $event2 Exploder=Attack:Normal+Nodivisor Oneself FixedHit Quiet Nouncon,0,
  >   Damage=HP

  Last but not least, this type of attack can be used by an enemy as a last
  resort. This two-stage attack first damages its target with the amount of the
  caster's Hit Points minus the target's Magic Resistance. Independent of the
  first attack's success, the second stage kicks in and, because of the
  "Oneself" flag, targets the caster himself. The damage done to the caster is
  equal to his remaining Hit Points, and with the "Normal" Attack Type and
  "FixedHit" flag set, the damage cannot be defended against and is fatal.
  Players using Sacrifice spells in battle will never gain anything except to
  aid battle comrades who might have a chance of winning.

See also: Elements, Pyramid Curve, Status Attacks, Status Attributes

&& Status Attacks, Combat

Status Attacks

  There are two additional types of attacks that the Attack Event is capable
  of performing: Status Attacks and Condition Attacks. Status Attacks are
  modifiers to a target's status attribute, either permanent or temporary, and
  consist of either damage that lowers a stat value or curation that raises it
  above the original value. There can be only one attribute change per Attack
  Event. On the other hand, Condition Attacks are positive or negative
  applications to one or more of a target's conditions. Multiple Condition
  Attacks can be specified distinctly or in groups in a single Attack Event.
  
  Each type has several ways it could be applied to the combat target. The
  chart below lists the available types of persistence for a status change,
  showing how long each type lasts during gameplay. The C or S below means that
  the type is available for condition changes or status changes, respectively.
  
  C   Wish      - Overrides all other conditions as a permanent change.
  C   Race      - Set at player creation time, or an innate monster ability.
  CS  Normal    - Set until removed by an item or resting at an inn.
  CS  Duration  - Lasts for a number of seconds or until removed by item/inn.
  CS  Room      - Lasts until the target leaves the room.
   S  Gradual   - The status modification gradually wears off 1/7th per round.
  CS  Battle    - Lasts until all the foes in the room are defeated.
  CS  Charges   - Remains in effect until retrieved by combat system X times.
  CS  Round     - Remains in effect until X rounds have passed or battle ends.

Permanent Status Attacks:

  A Status Attack is defined as any damage or healing performed to a target's
  stat other than HP, MP, or EN. The most basic stat change is a permanent
  modifier, performed by using the "Stat=<Stat Name>" event option. With this
  option, the event will modify the target's base stat value. The following
  example demonstrates a use for a permanent stat change--a rare item that
  raises your Strength by 2-4 points. The event requires the "Cure" element in
  order to raise the stat instead of damaging it.

  > $event1 Strength Seed=Attack:Normal+Pyramid,Cure,Stat=STR,Damage=2|4

  <Stat Name> can be any one of the first column of status attributes listed on
  the 'help Status Attributes' page, from 0 to 31. The attributes for HPLOSS,
  MPLOSS, and ENLOSS are special in that their idea of damage and curation is
  reversed on the stat itself. For instance, to damage HPLOSS means to increase
  the stat value of HPLOSS on the target, thereby reducing the target's Maximum
  Hit Points from its original value. Curing HPLOSS will restore the target's
  Maximum Hit Points closer to its original value. In this sense, the target
  will still defend against the damaging of HPLOSS and allow the curing of
  HPLOSS to pass through.

  Note: Besides players, only things with the Familiar condition can receive
        permanent status changes (excluding HP, HPLOSS, etc). For all others,
        the Attack Event switches to using the ST:Inn attack type (see below).
        This preserves the original stats set by the monster designer, allowing
        them to return to normal when defeated.

Temporary Status Attacks:

  Temporary status effects are achieved by changing the base <Attack Type> in
  [Arg0] of the Attack Event to a set of special keywords. Apart from those
  listed in 'help Event Attack' ("Normal", "Physical", etc), there are 6 other
  Attack Types used only for Status Attacks. Flags, such as "Pyramid", can be
  added to the keyword just like in a regular attack.

    ST:Inn      - Lasts until the target sleeps at an inn.
    ST:Duration - Lasts #seconds as specified with the "Duration=" equation.
    ST:Room     - Lasts until the target leaves the current room.
    ST:Gradual  - Wears off 1/7th per each round while engaged in battle.
    ST:Battle   - Lasts until all foes in the room are defeated.
    ST:Charges  - Lasts until the stat value is retrieved by the combat system.
    ST:Round    - Lasts for #round as specified with the "Charges=" equation.

  Technically, the game stores a separate +/- value for each status attribute
  and each Attack Type. Multiple changes to a target's temporary status will
  modify this +/- value accordingly. However, the "ST:Duration", "ST:Charges",
  and "ST:Round" Attack Types store a remaining number of seconds or charges in
  addition to the +/- value. Each attack event that modifies these two types
  will replace the original Duration or number of Charges with the new one set
  by the event.

  Since status changes affect the target's apparent status value, spell
  designers must be aware of the outcome of successive lowering or raising on
  the same enemy stat. Like with damaging attacks, the keyword E.<Stat> can be
  used in a "Damage=" equation to refer to the enemy's status value versus the
  caster's. Because status changes can be stacked, designers should use
  E.NOMOD.<Stat> in their equations to calculate based on the original value of
  an enemy's stat without the modifiers applied from any previous spellcasting.
  Stat Limiters (see Spell Stacking below) can be used to automatically cap the
  range in which status values can grow.

  A shorthand method to using E.NOMOD.<Stat> is to end the "Damage=" equation
  with a %. This forces the actual amount of damage to depend on the percentage
  of the target's stat referred to by <Stat Name> without status modifiers
  included. In other words, the equation "Stat=STR,Damage=25%" is equivalent to
  "Stat=STR,Damage=E.NOMOD.STR*25%".

  Note: Using NOMOD on a Calculated Stat such as DEF returns the player's base
        Defense Power, which includes all stat changes that modify VIT directly
        but not those that modify DEF. This allows designers to focus on
        changes to VIT as raw innate power enhancements and changes to DEF as
        external defense in melee combat, for example.
  
  When using the "ST:Charges" Attack Type, the "Charges=" equation determines
  how many times the combat system will use the temporary stat change. Further-
  more, only a certain number of stats can be used with the "ST:Charges" Attack
  Type. The chart below describes when the combat system will decrement a
  charge on each stat attribute during the battle (those not present cannot be
  used with "ST:Charges").

    STR or ATK    - During a physical attack.
    VIT or DEF    - When attacked physically by another enemy, or struck with a
                    physical condition.
    INT or MATK   - When casting an offensive magic spell.
    WIS or MDEF   - When casting a curative magic spell, attacked magically by
                    another enemy, or struck with a magical condition.
    AGL or VIGOR  - When attempting to run away, or at the beginning of a round
                    of combat when the length of the round is calculated.
    DEX or HIT    - During any physical attack that can miss its target.
    LUCK or EVD   - When attacked physically by another enemy.
    MHIT          - During any magical attack that can miss its target.
    MEVD          - When attacked magically by another enemy.
    WILL          - When using or defending against a Psionic spell, or struck
                    with a mental condition.
    CRIT          - After executing an Attack Event with the Critical flag set.
    REPR          - When attacked by another enemy that warrants a reprisal.
    CHANT         - When casting the next spell.
    SKILL         - When performing the next technique.

  Enemies can defend against harmful status attacks by protecting against one
  of five conditions, listed below. The type of status attribute determines
  which condition is tested. Enemies protecting against the condition at Level
  10 or higher will completely block the status effect, resulting in the event
  missing its target.

    PhysStat   - MAXHP, HPLOSS, STR, VIT, ATK, DEF, REGEN, ATKS, DIVISOR, DRAIN
    MagicStat  - MAXMP, MPLOSS, INT, WIS, CHANT, MATK, MDEF, SPLV
    EndStat    - MAXEN, ENLOSS, AGL, CRIT, REPR, SKILL, EXPR, VIGOR, MAXMOVES
    AccStat    - DEX, LUCK, HIT, EVD, MHIT, MEVD, FUMBLE
    MindStat   - WILL, ALIGN
  
  The following example illustrates the use of temporary status attacks:

  > $event1 Break Guard=Attack:ST:Battle,0,Stat=DEF,Damage=E.DEF*50%

  The above event halves the target's Defense Power every time it is cast.
  The effect is cumulative, with Damage equaling 50% of the target's current
  Defense score, such that each time it is cast it will do less and less
  damage. Because of the Attack Type "St:Battle", the target's Defense will
  return to normal when all of the target's foes in the room are defeated. Note
  that if the equation "Damage=50%" was used in place of "Damage=E.DEF*50%",
  then the attack would damage using 50% of the target's base value instead of
  the current value set by the previous casting.

Spell Stacking:

  The combat system is designed to support flexible spell stacking for status
  effects. Successive spell-casting of temporary status changes can be limited
  by either a hard limit or by automatically decreasing the potency of the
  spell when cast many times in a row.
  
  A hard limit is specified by using the option "Stat=<Stat Name>:<Limit>",
  where <Limit> is the maximum number of points the player's stat can be
  increased or decreased beyond his base stat with this spell (across
  successive technique uses). Any attempts to change the stat beyond this limit
  will result in a Miss. <Limit> can be followed by a % sign to calculate a
  percentage of the player's base stat in place of points.
  
  Limits with percentages are useful for status buildup that allows a spell to
  be cast only a certain number of times for increased power. For instance, the
  following example shows a spell that lets the caster raise his Attack Power a
  total of 2 times up to 200% of his original ATK score, in increments of 50%.

  > $event1 Might=Attack:ST:Room,Cure,Stat=ATK:100%,Damage=50%

  The second method to limit successive spell-casting can be achieved through
  the use of the "Decay" flag, set in [Arg0] of the Attack Event. This flag
  reduces the Damage equation based on the difference of the current stat value
  versus the original base value. The first time the spell is used, the
  target's stat will rise or lower the full amount. The second time, it will
  rise or lower only half of that amount, and so on. With enough casts, the
  spell will eventually cap at twice the full amount possible.

  For instance, the following example raises Intelligence by 50%. If the
  target's original INT score is 60, this spell will increase it to 90. If cast
  again, the spell will increase it to 105, then 113, 117, 119, and finally cap
  at 120. The actual increases in INT with each successive cast were 30, 15, 8,
  4, 2, and 1, following a 50% rate of decay. Therefore, the limit this spell
  can reach is 120 from 60, or twice that of the full 50% damage rating.

  > $event1 Celerity=Attack:ST:Gradual+Decay,Cure,Stat=INT,Damage=50%

  Note: Even if the current stat value is lower than the base value, one spell
        casting will never increase the stat more than the rated "Damage="
        equation.

Condition Attacks:

See also: Event Attack, Status Attributes

&& Event Restore, Combat

2. Restore

  This event completely restores the HP/MP/EN of a target to maximum values,
  much like what happens when a player levels up. It also wipes out all harmful
  conditions and resets his HpLoss, MpLoss, and EnLoss to 0.

  There are two forms of the "Restore" event. When [Arg0] is set to 0 (the
  default), the event triggers on the target and the message "Your life is
  restored!" is displayed hilited. When [Arg0] is set to 1, this event mimics
  the effects of sleeping at an Inn by setting the target Asleep, displaying 3
  blank lines, and then printing the above message to the target after 5
  seconds. The player will be unable to type any commands during this time.
  Also when [Arg0] is 1, the target's Rests attribute will increase by 1,
  keeping track of the total number of stays at an Inn.

  Both forms of "Restore" can be used in combat, however they make more sense
  being called via the @event command as special actions in the storyline. Inns
  are especially encouraged to use this event. If used in combat, the message
  shown can be changed by setting $succ and $osucc on the spell.
  
Syntax:

  Arguments: <Action>

  [Arg0] Action:
    0 - Instant restore of a target character. Only harmful ailments are
        removed from the target.
    1 - Target sleeps for 5 seconds (even during battle) and restores HP/MP/EN.
        All temporary conditions, both harmful and helpful, are removed.

&& Event Escape, Combat

3. Escape

  This event causes the target to run away in fear, stopping all combat between
  the target and his opponents. The target will flee to any adjacent room that
  is not blocked or locked. When cast on oneself or an ally, this event will
  always succeed regardless of how many enemies are attacking the target at
  once. However, this event will never succeed if all exits are locked, unless
  an enemy uses it on itself (and not due to reflection).

  If the target is a non-mobile enemy, this technique will instantly teleport
  the target into itself and set it Dead. It is up to the softcode on the enemy
  to relocate to the desired room if this happens. If no softcode is present,
  there is a hardcode timer that loops every 15 minutes to restore all dead,
  dislocated enemies (those inside themselves) to their home positions and
  restore their status.
  
  This event will increment the Escape attribute on player targets by 1 for
  each use (non-attack). Enemies can resist an attack by applying a saving
  throw against the Fear condition.

Syntax:

  No arguments.

See also: run

&& Event Save, Combat

5. Save

  This event sets the Save Point Location of a target. The Save Point is the
  player's starting location after he comes back to life from a failed combat
  attempt. If [Arg0] is set to 0, this event behaves exactly like the 'save'
  command, as players are restricted to saving only in rooms set Abode. When
  [Arg0] is 1, players can save in any room except those occupied by a boss.

  This event only works for non-visitor player characters.

Syntax:

  Arguments: <Permissions>

  [Arg0] Permissions:
    0 - Only allow saving in owned rooms or rooms set Abode.
    1 - Allows saving in ANY room except those set Nest or X-Zone.

Example:

  > $type Second Chance=Item
  > $flags Second Chance=Legendary
  > $event1 Second Chance=Save,1
  > $lock Second Chance=[wmatch(zone(v(L)),#xxx)]
  Creates an item that allows the player to save anywhere in a specified zone.
  Being Legendary, the player cannot give this item away and only gets one
  special chance to create a Save Point for himself.

See also: save

&& Event Rename, Combat

6. Rename

  Allows the caster to change his character's name. A valid name must be
  between 3 and 16 characters and cannot contain spaces or non-alphanumeric
  symbols except for a _. All name changes are logged to a file that any Wizard
  can read.
  
  No arguments are required for this event. The player specifies the new name
  as the target on the command-line.

  Note: Be careful that the spell or item using this event has its $areaatk set
        to "Notarget". If this is not set, players may be able to change the
        names of others in the room.

See also: @name

&& Event Teleport, Combat

7. Teleport

  Instantly warps a player (caster or target) from one room to another in the
  world. A method of teleportation is specified by a keyword and optional flags
  in [Arg0] (see below), along with an optional room number for a constant
  destination in [Arg1]. If set, the spell's $remote message will be displayed
  to everyone in the destination room immediately before the target arrives.
  
  Teleport can additionally be used as an attack spell to send enemies away
  without gaining any Experience Points. Enemies can resist the warp if they
  make a successful saving throw versus the Warp condition (unless they use
  the event on themselves). Teleporting generic enemies set with the Monster
  flag will instantly slay them as if the player had normally defeated them,
  rather than actually teleporting them to the destination. This feature can be
  used by NPCs to feign escaping from battle during storyline events. The rate
  of a successful teleport against an enemy with no Warp protection is
  specified as a combat equation in [Arg2].

  This spell can be used with the "Memorize" event to teleport to other
  locations above ground that the caster has previously memorized.

Syntax:

  Arguments: <Method+Flags>,<Room/Zone>,<Rate>

  [Arg0] Teleportation Methods: (one of the following)
    Fixed  - Teleport to a fixed room or zone. This is the default if not
             specified with any arguments. A valid room# or zone# must be
             stored in [Arg1] to be successful. If [Arg1] is 0 or missing, then
             the config variable PLAYER_START is chosen. If a zone# is used,
             then the player is transported to the zone's link point.
    Home   - Teleport to starting location. This sends the player to his Save
             Point just like when a player recovers from death.
    Escape - Escape a dungeon and teleport to the Zone Entrance. This only
             works in zones whose sectors have the SF_ESCAPE flag (e.g.
             Dungeon, Caverns, and Tower). Players are sent to the zone's link,
             which is generally the room just outside of the dungeon.
    Last   - Teleport to the last town visited. If players have not yet visited
             any towns, then this sends them to their starting location.
    Town   - Allows players to choose their destination from a list of towns
             visited. Towns are defined by Zone Object and stored as a series
             of 2-bit numbers with the @town command (see below).
    Random - Teleports to a random room in the caster's current zone or in the
             zone# marked by [Arg1] (if not blank). All rooms not marked Nest
             or X-Zone are possible targets. The NoWarp condition can be set on
             a room to prevent it from being accessed.
    Wizard - Wizard Teleport! Like "Town", however it lets the player choose
             any town defined in the '@list towns' list.

  [Arg0] Flags: (add zero or more of the following)
    Anywhere - Disregards the current sector type when teleporting. This allows
               "Escape" to work in non-dungeon environments and allows other
               methods to work in non-outside/wilderness areas.
    Wall     - Allows teleporting from rooms set Wall.
    Nest     - Allows teleporting from rooms set Nest (automatically implied
               for NPCs).
    Target   - User must specify the target of the spell rather than the town
               destination. This is used primarily for Teleport attacks against
               enemies. To maintain storyline restrictions, other players can
               only be teleported to places they have already visited.
    NoLoc    - Suppress all destinations memorized through the use of the
               "Memorize" event. Players will not be able to select them.
    Visited  - Used with the "Random" flag to only allow access to rooms that
               players have visited. This requires that each accessible room
               has an Explore% value established with @addexplore.

  [Arg1] Room/Zone Object:
    This argument only has meaning for when [Arg0] is set to "Fixed" or
    "Random". This specifies the room or zone dbref# for the spell's
    destination.

  [Arg2] Rate: A combat equation that evaluates to the percent of success in
    teleporting a target against its will to the destination. If '200' or
    higher is used, or if the target is a party member, then the spell is
    always successful.

Caption Variables:

  %1 - The success rate of an offensive "Teleport" attack; same as [Arg2].

Sector Restrictions:

  Certain sectors restrict teleporting based on the method defined in [Arg0].
  For all Teleport methods except "Escape" and "Random", players can only
  teleport from outside areas such as wilderness and towns. When [Arg0] is
  "Escape", players can only teleport from deep inside dungeons. "Random"
  teleports can be used in any sector type.

  The table below summarizes the sectors from which players can Teleport:
  
         Sector Type         Teleport:      Escape:
       ---------------       ---------      -------
         0 Normal                *
         1 Town                  *
         2 Wilderness            *
         3 Dungeon                             *
         4 Castle
         5 Underwater
         6 Mountains             *
         7 Swampland             *
         8 Desert                *
         9 Arctic                *
        10 Ship
        11 Shrine
        12 Caverns                             *
        13 Tower                               *
        14 Ethereal              *

  Teleportation is unrestricted when the "Anywhere" flag is present in [Arg0].

Town Configuration:

  Each accessible town in the game must be defined according to Name and Zone#
  by using the @town command. Towns must have a special 2-bit storyline bitmap
  assigned to them to hold the data for which towns are visited on a per-player
  basis. Once defined, a player entering a town's zone for the first time will
  have his bitmap value automatically set to 1 for that town. Softcode in the
  game can alternatively set the bitmap value to 2 or 3, whose meaning is
  summarized in the table below:

   0 - Town hasn't been visited yet. The game will automatically set this value
       to 1 when the player enters the zone.
   1 - Town has been visited and the town is selectable from the Teleport menu.
   2 - Town is grayed out on the Teleport menu and cannot be chosen. This is
       most likely used to indicate a town that has been destroyed during the
       course of the story, or one that is no longer accessible.
   3 - Town does not appear on the Teleport menu and cannot be chosen, however
       the game will not automatically enable this town when the player enters
       the zone.
  
  Only storyline bitmaps 2048 and up can be used as data for towns. If one town
  is defined at bit position 2054, for instance, the next one could be defined
  at 2056.

Examples:

  > $event1 Wind Essence=Teleport:Escape
  > $succ Wind Essence=You call upon the powers of the wind. In a flurry, you
  >   find yourself back at the entrance of the dungeon.
  > $osucc Wind Essence=%N calls upon the powers of the wind and disappears in
  >   a flash of light.
  Allows players to escape from the depths of a dungeon.

  > $event1 Warp Boots=Teleport:Town
  > $succ Warp Boots=You tap your %0 three times in the direction of %3. In a
  >   matter of seconds, your surroundings fade from view.
  > $osucc Warp Boots=%N taps %p %0 towards %3. In a matter of seconds, %N
  >   fades completely from sight!
  > $remote Warp Boots=A twinkling of light appears before you, as %N fades
  >   into view.
  A basic item that, when used, teleports to a town once visited in the past.

  > $event1 Word of Recall=Teleport:Home+Anywhere
  Sends the player to his Save Point, regardless if he is on the field or in
  a dungeon. Players cannot use this while in boss battles or while magic is
  sealed from a room.

See also: @town, $remote, Event Memorize

&& Event Fuel, Combat

13. Fuel

  Refuels oil lamps with a specified amount of burning oil. Only lamp items
  whose $lightsrc attribute is '2' can be targetted with this event. The lamp
  need not be equipped or unlit to add fuel.

  Technically, this event subtracts the $lightcount variable on the target item
  by [Arg0] seconds. It cannot be used if the item is already completely full
  ($lightcount = 0). Any leftover fuel is discarded.
  
  This event has no meaning if [Arg0] is 0 or less.

Syntax:

  Arguments: <Fuel>

  [Arg0] Fuel: The number of seconds of fuel to add to the oil lamp.

Caption Variables:

  %1 - Amount of Fuel in the container; same as [Arg0].

See also: $lightcount, $lightsrc

&& Event Memorize, Combat

14. Memorize

  Memorize allows a player to record his current location into a personal list
  for use with the "Teleport" event. Once recorded, the location will appear
  below the list of possible town destinations in the spells/items screen. The
  player can then choose to teleport back to this location using any item or
  spell that lets him select the warp destination.

  The number of locations possible to memorize at once is defined in [Arg2] as
  a combat equation. When a player reaches the maximum number of locations,
  subsequent memorize attempts will rotate the list such that the first
  location falls off and the new location is entered into the last slot.
  Players can also specify the slot to record the location as the target of the
  technique.

  Memorized locations appear in the list as 'Loc1' through 'LocN' and are
  accompanied by the name of the destination zone or the name of the room if
  no zone is set.

Syntax:

  Arguments: <Zone Types>,<Duration>,<Number>

  [Arg0] Zone Types: (one of the following)
    Wilderness - Limits the technique to memorizing rooms in SF_TELEPORT
                 sectors (Wilderness and Towns) and zoneless rooms.
    Sanctuary  - Allows memorization in SF_TELEPORT sectors as well as Shrines,
                 Ships, and Castles.
    Dungeons   - Allows memorization anywhere except Wall and Nest rooms.
    Anywhere   - Allows memorization anywhere except Nest rooms.

  [Arg1] Duration: A combat equation specifying the number of real-life days
         the location stays in memory on the player. If this field evaluates to
         '0' or is missing, then the location is permanent until overwritten.
         The maximum value is 99999 days.

  [Arg2] Number: A combat equation specifying the number of locations possible
         to memorize at once. If this field is '0' or is missing, the number is
         unlimited.

Caption Variables:

  %1 - The number of days a player will retain the location; same as [Arg1].
  %2 - The number of locations possible to memorize at once; same as [Arg2].

Example:

  > $event1 Memorize Location=Memorize:Wilderness,0,SPLV+2
  A standard memorization spell that allows up to 3 locations + 1 additional
  for every spell level raised.

See also: Event Teleport

&& Event Message, Combat

18. Message

  This event displays a series of delayed messages to everyone in the room of
  the caster. It is mainly used as a countdown device for an upcoming powerful
  attack. The text in the spell's $eventmsg attribute is used as the contents
  of the message, and the variable %3 evaluates to the current count number
  that either increases or decreases with each display.

  The event returns Successful if it is the last event stored in a technique
  that only contains Message events. Otherwise, it returns No-Effect, allowing
  the return code of the real non-Message technique to pass through.

Syntax:

  Arguments: <Number>,<Delay>,<Flags>

  [Arg0] Number: The total number of messages to display in this event. There
         is a hard limit of 255 messages per event.

  [Arg1] Delay: The time delay between successive event messages, in tenths of
         seconds.

  [Arg2] Flags: (zero or more of the following)
    Battle    - Changes the text of the last message to be displayed as a
                -< Battle >- announcement instead of an $eventmsg attribute.
                By using this flag and setting the spell's $flags attribute to
                "Quiet", you can display a series of messages before the
                -< Battle >- line announces the execution of the spell.
    Finalmsg  - When coupled with the "Battle" flag, this immediately displays
                a final $eventmsg attribute after the -< Battle >- line without
                any extra time delay.
    Countdown - Makes message numbers count downward, starting with <Number>
                and ending with the last message as 1. If "Battle" is present,
                then message numbers start at <Number> - 1 and end at 0.

Examples:

  > $event1 Assess=Message
  > $eventmsg Assess=%U is assessing the situation.
  A simple event that just displays a line of text in the caster's room. It
  always returns Successful.

  > $event1 Report=Message:2,40
  > $eventmsg Report=Checking battle program %3...
  This event displays 2 messages 4 seconds apart from each other. %3 evaluates
  to '1' in the first message and '2' in the second.

  > $event1 Energy Boost=Message:2,120,Battle Finalmsg
  > $event2 Energy Boost=Attack:Physical+Weapon DamageEQ Pyramid Critical,0,
  >   Damage=ATK*300%
  > $eventmsg Energy Boost=[s(ifelse(eq(v(3),1),{%U is building up energy.},
  >   {%U releases %p power!}))]
  > $flags Energy Boost=Quiet
  An attack spell that warns the target 12 seconds before the spell executes.
  When the event triggers, the first message '%U is building up energy.' is
  shown. 12 seconds elapse until the messages '-< Energy Boost >-' and '%U
  releases %p power!' are displayed and $event2 executes. The technique's
  success depends on the result of event 2.

  > $event1 Exploder=Message:4,30,Battle Finalmsg Countdown
  > $event2 Exploder=Attack:Magical+DamageEQ Pyramid Divide,Fire,Damage=HP
  > $event3 Exploder=Attack,0,Force:Normal+Nodivisor Oneself FixedHit Quiet
  >   Nouncon,0,Damage=HP
  > $eventmsg Exploder=[if(eq(v(3),3),{Self destructing in })][s(ifelse(v(3),
  >   {%3...},{%U explodes!}))]
  > $flags Exploder=Quiet
  Displays a countdown starting with the first message as 'Self destructing in
  3...', followed by '2...', '1...', and then the battle line '-< Exploder >-'
  immediately followed by 'Caster explodes!'. Although there are 4 messages
  total, the messages end at 0 instead of 1 because of the "Battle" flag. The
  technique's return value depends on the success of events 2 and 3.

See also: $eventmsg

&& Event Advance, Combat

19. Advance

  This event increases the number of technique points, mastery percentage, or
  the levels of spells and skills known by a target. You can allow this event
  to teach new techniques, levelup existing techniques, or both (this is the
  default).

  Based on the <Flags> specified below, you have 3 ways to raise a Spell or
  Skill. First, <Amount> can be a number of Technique Points given directly to
  the technique--governed under normal levelup rules. Second, <Amount> can be
  an amount of Percentage Points applied directly to the technique (spells will
  not gain percent beyond their current level). Third, spells can be given
  direct increases in level.
  
  New spells and techniques begin at Level 0. New skills begin with 1% mastery.

Syntax:

  Arguments: <Technique Type>,<Technique>,<Amount>,<Flags>,<Limit>,<Initial>

  [Arg0] Technique Type: Only the following types can be used with this event:
         Types may be abbreviated:

                 Language                   Weapon Proficiency
                 Skills                     Prayers
                 Spells                     Powers
                 Techniques

  [Arg1] Technique: A valid technique entry (specific spell, skill, etc.) for
         the type in [Arg0] must be specified. If set to 0 or omitted, the
         caster must choose the name of an item in his technique slot to
         receive the award.

  [Arg2] Amount: The number of technique points, mastery percent, or spell
         levels to be awarded to the player. The type of amount is determined
         by [Arg3].

  [Arg3] Method: (one of the following)
    Percent - The default method: For spells, raises its percent by [Arg2]
              within the current level. For skills, raises its mastery
              percentage by [Arg2].
    Level   - For spells, raises the spell [Arg2] levels. For skills, raises
              its mastery percentage by [Arg2] percent.
    Techpts - Awards [Arg2] Technique Points to the target's technique.

  [Arg3] Flags: (add zero or more of the following)
    Levelup  - Restrict to only leveling-up existing techniques on the target.
    New      - Restrict to only teaching new techniques the target hasn't yet
               learned.
    Quiet    - Do not announce an award, even if a spell levels or is mastered.
    Training - Mark newly-learned spells as "Training" until they are raised to
               Level 1. Spells set "Training" are not shown in the normal spell
               list but are shown with their percentage when viewing Abilities
               used by Junctions or Summons.

  [Arg4] Limit: The maximum Spell Level or Skill Mastery % allowed via this
         event. Disregarding <Limit>, spell levels can't advance higher than 10
         and skills can't be learned above 100%. If set to 0 or unspecified,
         normal spell/skill limits apply.

  [Arg5] Initial: This value overrides [Arg2] as the amount to set the Percent
         and Level when a target learns a new technique. This allows for an
         event to advance a technique with two different values depending on if
         the target knows the skill already. This argument only has meaning
         when neither flags "Levelup" or "New" are set. Note that the initial
         value when using method "Techpts" is always 0, regardless.

  Note: Raising Language techniques will not display any message until its
        Mastery percentage reaches 10% or higher.

Examples:

  > $event1 Archery Badge=Advance:Skill,Aim,5,New
  Teaches the new skill "Aim" to a target, beginning at 5%. The event does not
  increase a target's existing skill.

  > $event1 Swimming Boost=Advance:Skill,Swimming,-1,10
  Increases a target's Swimming skill by 10%, only if he had already learned
  the skill.

  > $event1 Wind Shard=Teach:Technique,Aero Blade,0,1,5
  Teaches the technique "Aero Blade" to a target at Level 0, or otherwise
  increases the target's technique level by 1, up to a maximum of 5.

&& Event Recharge Mana, Combat

20. Recharge Mana

  This event allows a caster to transfer a specific amount of Magic Power into
  a touchstone, room, or combat item of the player's choice. The room must
  have the @mana attribute set, or the item must have the $maxmana variable
  set, to receive Magic Power. The event's arguments define the ratio of points
  stored on the object versus the MP expenditure by the caster.

Syntax:

  Arguments: <Amount>,<Object Types>

  [Arg0] Amount: The amount of Magic Power to store during a single execution
         of this event. This ratio to MP cost and the $manacharge variable on
         the target item determines the efficiency of the storage.

  [Arg1] Object Types: (one or more of the following)
    Room       - (Default) Allows a player to store magic to the current room.
                 No target is necessary if [Arg1] only contains this flag.
    Touchstone - Allows a player to store magic on a combat item whose $type is
                 "Touchstone".
    Magical    - Lets a player store magic on any item with a $maxmana set.
  
See also: Draw Points

&& EQFX Status, Combat

1. EQFX Status

  This effect applies a modifier to an individual Status Attribute on a player. 
  [Arg0] contains the attribute to be changed, with flags in [Arg1] determining
  how to alter the value. Depending on the flags used, the value in [Arg2] can
  be applied as a +/- modifier, a percentage or divisor of the existing stat
  value, or it can override the player's stat completely.

  Percentages and divisors are always taken from the player's base stat value,
  which is the value before any equipment modifications are calculated.

Syntax:

  Arguments: <Status Attribute>,<Flags>,<Value>

  [Arg0] Status Attribute: Must be a combat variable listed on the 'help Status
         Attributes' page. They can be specified using either the abbreviation
         or the full attribute name. Attributes 32-49 and 51 cannot have
         modifications applied to them.

  [Arg1] Types: (one of the following)
    Fixed   - (Default) The value in [Arg2] is used as specified.
    Percent - [Arg2] is applied as a percentage of player's base stat value.
    Divide  - Value applied is equal to player's base stat divided by [Arg2].

  [Arg1] Flags: (zero or more of the following)
    Modify  - Value is to be applied as a +/- modifier. Without this flag, the
              player's stat is overridden rather than adjusted.
    Weapon  - Only in effect when the item is wielded during an attack.

  [Arg2] Value: The actual value to be applied to the status attribute.
         Negative values can be used to decrease (instead of increase) a stat.

Examples:

  ATK,Modify,10          => Increases Attack Power by 10.
  # Attacks,Modify,1     => Increases number of attacks per round by 1.
  INT,Percent Modify,50  => Increases Intelligence by 50%.
  Chant Rate,Fixed,75    => Sets player's Chant Rate to 75 regardless.

See also: Status Attributes

&& EQFX Condition, Combat

2. EQFX Condition

  This effect applies a temporary condition to the player that disappears only
  when the equipment is taken off or destroyed in battle. Any type of condition
  application can be specified as flags to [Arg1], just as if the player had
  acquired the condition due to the normal casting of a spell or technique.

  Saving-throws still apply when using condition attacks against an opponent.
  A target may resist a condition change when using the "Attack" flag with
  ailments such as Poison and Paralysis, or when using the "Remedy" flag with
  helpful conditions such as Quick and Invisibility. Thus, a condition change
  may not be successful even at a specified 100% Rate.

Syntax:

  Arguments: <Condition>,<Flags>,<Value/Level>,<Rate>

  [Arg0] Condition: Name or number of the condition to modify on the player.

  [Arg1] Types: (one of the following)
    Fixed     - (Default) Player's condition is set to the value in [Arg2].
    Modify    - Value in [Arg2] is added/subtracted to player's condition.
    Permanent - Player's condition is set to [Arg2], disregarding all other
                condition modifications by other equipment. Equipment at the
                top of the 'equip' list gets priority over lower items.
    Highest   - Player's condition is set to [Arg2] only if the current value
                is less than [Arg2].

  [Arg1] Levels: (combine one of the following)
    Set       - (Default) Condition is set on player with Value=[Arg2].
    Protect   - Saving-throw protection against condition with Level=[Arg2].
    Attack    - Inflicts condition-setting with every weapon attack. Uses
                attack Level=[Arg2] and Rate=[Arg3] out of 1000.
    Remedy    - Inflicts condition-remedy ability while attacking. Uses attack
                Level=[Arg2] and Rate=[Arg3] out of 1000.
    Element   - Weapons gain this elemental property while attacking.
    Reflect   - Reflects attacks consisting of this element back at the caster.
                Value=[Arg2] is 1 for 50% damage, 2 for 100%, and 3 for 200%.

  [Arg1] Flags: (zero or more of the following)
    Break     - This equipment will shatter during a successful saving throw,
                condition inflict/remedy, or elemental defense/reflection. Rate
                of destruction is always 100% when "Attack" and "Remedy" are
                selected, otherwise equipment breaks in [Arg3] out of 1000.
    Weapon    - Only in effect when the item is wielded during an attack.

  [Arg2] Value: The value to be applied to the condition, or the attack/saving-
         throw level when [Arg1] is "Attack" or "Remedy".

  [Arg3] Rate: A number from 0 to 1000 specifying how often (out of 1000) an
         action should be triggered. If 0 is specified, the condition is always
         triggered.

  Note: All elemental defense occurs using a normal condition Set, not Protect.
        Protecting against elementals means to save against becoming weak vs.
        that element.

Examples:
  
  Berserk,Fixed,1      => Berserk Gloves; forces wearer to go berserk during
                          each battle.
  Scan,Fixed,1         => Sight Scope; displays HP data on enemy captions.
  Fire,Modify,-1       => Ice Shield; lowers defense against Fire attacks by 1.
  Petrified,Protect,2  => Stone Check; protects against becoming petrified
                          with a saving throw of Level 2.
  Divine,Break,1       => Opal Statue; resurrects player at death, then breaks.

  Poison,Attack+Weapon,4,100  => Poison Claw; 1 in 10 inflicts Level 4 poison.

See also: EQFX Element, Status Attacks, @list Conditions

&& EQFX Restrict, Combat

3. EQFX Restrict

  This effect restricts players to certain classes which are able to equip a
  specific item for combat. Equipment can be locked both by class (such as
  Race, Guild and Gender) and either above or below a certain Race or Guild
  Level. Items can also have multiple restrictions, which allow players to
  equip them if they match any one criteria. This can be overridden using the
  "Required" flag, which forces all restrictions on the equipment to be met.
  
  As players change guilds or reach a new experience level, all equipment that
  no longer meets the restriction criteria will be automatically unequipped.
  
Syntax:

  Arguments: <Type+Flags>,<Class>,<Level>

  [Arg0] Types: (one of the following)
    Race        - Restrict to a specific race.
    Guild       - Restrict to those who have membership (past or present) in a
                  specific guild.
    Family      - Restrict to a specific genus family.
    Gender      - Restrict to either Male or Female.
    Proficiency - Restrict to wearer's Weapon Proficiency Level (weapons only).

  [Arg0] Flags: (zero or more of the following)
    Reverse     - Flip restriction to match only those below a certain level.
    Exclude     - Only those who DON'T match this criteria can equip this item.
    Required    - This flag forces all restrictions on the equipment to be met
                  before the player can equip this item. At least one Restrict
                  EQFX must have this flag set to use this feature.

  [Arg1] Class: Specific class of Type=[Arg0] that the restriction applies to.
         "Gender" type must specify either Male or Female. Class=0 can be used
         for "Race" or "Guild" to match the level of any race or guild.

  [Arg2] Level: Level restriction for equipment; refers to Race Level unless
         [Arg0] is set to "Guild" or "Proficiency". All players with level
         equal or higher to [Arg2] meet this criteria.

Examples:

  Race,Centaur       => Riding Cape; only Centaurs can wear this cape.
  Gender,Female      => Minerva Guard; only women can wear this item.
  Guild,Bard,6       => Illusive Shamisen; only Bards with enough practice at
                        Guild Level 6 can operate this instrument.
  Race,0,100         => Atma Weapon; restrict to any race at or over Level 100.
  Guild+Exclude,0,1  => Newbie Staff; restricts to any player who has not yet
                        chosen a guild (has no guild level at 1 or higher).
  Proficiency,0,5    => Vorpal Sword; requires Sword proficiency of Level 5.

&& EQFX Apply, Combat

4. EQFX Apply

  This effect applies an additional EQFX conditionally based on certain class
  levels for either the player equipping the item or his target opponent in
  battle. If the player's criteria matches, then the EQFX immediately following
  in the list becomes applied to the player, otherwise the EQFX is skipped.

  By default, this effect only matches the target opponent--the most common
  case. The "Oneself" flag must be used to match the player's criteria instead.
  When matching against an attacker's (or target's) criteria, the following
  EQFX is applied only for the duration that a battle technique is being used
  against a target or against you by an attacker.

  Multiple Apply EQFX can be used in succession if multiple criteria must be
  matched for a specific effect. If many criteria should be matched in an OR
  fashion instead, simply use multiple groups of Apply EQFX.
  
Syntax:

  Arguments: <Type+Flags>,<Class>,<Level>

  [Arg0] Types: (one of the following)
    Race        - Apply on a specific race (players only).
    Guild       - Apply on those who have membership (past or present) in a
                  specific guild.
    Family      - Apply on a specific genus family.
    Gender      - Apply if either Male or Female.
    Proficiency - Apply on wearer's Weapon Proficiency Level (weapons only).
    Sector      - Apply only if player is located in a specific sector type.
    Random      - Apply randomly in [Arg1] out of 1000 events.

  [Arg0] Flags: (zero or more of the following)
    Reverse     - Apply only on those below a certain level in [Arg2].
    Exclude     - Apply only on those who DON'T match this criteria.
    Oneself     - Apply based on the player's Type/Class instead of the
                  player's combat opponent. Has no effect if [Arg0] is
                  "Proficiency", "Sector", or "Random".

  [Arg1] Class: Specific class of Type=[Arg0] that the restriction applies to.
         "Gender" type must specify either Male or Female. Class=0 can be used
         for "Race" or "Guild" to match the level of any race or guild.

  [Arg2] Level: Level restriction for application; refers to Race Level unless
         [Arg0] is set to "Guild" or "Proficiency". All players with level
         equal or higher to [Arg2] meet this criteria.

Examples:

  The following must be added in the order shown:

  > Apply,Family,Giant
  > Condition,Death,Attack,20        => Instantly slays Giants.

  > Apply,Family,Dragon
  > Status,DEF,Modify+Percent,50     => +50% Defense against Dragon attacks.

  > Apply,Sector,Desert
  > Status,VIGOR,Modify+Percent,-10  => Reduces battle delay by 10% in Desert.

  > Apply,Random,50
  > Condition,Fire,Highest,3         => Nullifies 1 in 20 Fire attacks (5%).

&& EQFX Regen, Combat

5. EQFX Regen

  This effect applies a regeneration rate to a player, which can either restore
  or deteriorate Hit Points, Magic Power, or Endurance over time. A player
  automatically dies without unconsciousness if his HP count reaches 0.

Syntax:

  Arguments: <Type>,<Regeneration>,<Amount>

  [Arg0] Type: (one or more of the following)
    HP       - Modify player's Hit Points (Default).
    MP       - Modify player's Magic Power.
    EN       - Modify player's Endurance.

  [Arg0] Flags: (zero or more of the following)
    Percent  - [Arg2] is given as a percentage of Maximum HP/MP/EN regenerated.

  [Arg1] Regeneration: (one or more of the following)
    Second   - Once every second.
    Minute   - Once every minute.
    Step     - Each step the player takes.
    Round    - At the front of each round of combat.
    Occasion - Occasionally during combat (1 in 7.5 seconds randomly).
    Combat   - Every 0.1 seconds while engaged in combat.

  [Arg2] Amount: Value to add or subtract from a player's current HP/MP/EN at
         each time regeneration goes into effect.

Examples:

  HP,Step,2            => Tintinnabulum; Increases HP by 2 for each step taken.
  HP+Percent,Round,10  => Refresh Ring; Increases HP by 10% every round.
  MP,Minute,7          => Magic Source; Increases MP by 7 once per minute.
  HP+MP+EN,Combat,-1   => Blood Ring; Decreases HP/MP/EN by 1 point every 0.1
                          seconds during battle.

&& EQFX Technique, Combat

6. EQFX Technique

  This effect temporarily grants a technique to the player at a specific
  mastery level. The technique functions just as if the player had normally
  learned it and will show up with a darkened blue background in the status
  sub-screens. The player loses his ability to use the technique once the item
  is unequipped.

Syntax:

  Arguments: <Technique Type>,<Technique>,<Level>,<Value>

  [Arg0] Technique Type: Only the following types can be applied by this EQFX.
         Types may be abbreviated:

                 Language                   Weapon Proficiency
                 Skills                     Limit Attacks
                 Spells                     Prayers
                 Techniques                 Powers

  [Arg1] Technique: A valid technique entry for the type in [Arg0] must be
         specified.

  [Arg2] Level: The level at which a combat technique is to be automatically
         known by the player (or the percentage for Language and Skill). If the
         player has already learned the technique, the entry with the highest
         level or percentage will be used. If the highest level is set due to
         EQFX, then that player cannot increase his skill level with Technique
         Points until the equipment is removed.

  [Arg3] Value: Only used when the selected type for [Arg0] is "Limit Attacks".
         This value is equal to the percent of Impact Points (IP) consumed in
         order to perform the technique.

  Note: If [Arg2] is set to 255, then the player will temporarily forget the
        technique learned. This is useful for cursed equipment.

Examples:

  Skill,Steal,15         => Thief's Robe; Gives the player a 15% Steal skill
                            level while equipped.
  Language,Arcane,50     => Crest of the Magi; Gives the player the ability to
                            read Magical Scrolls.
  Limit,Cure Light,1,50  => Angel Gown; Allows the use of the Cure Light spell
                            on Level 1 at 50% IP.

See also: @list Techniques

&& EQFX Teach, Combat

7. EQFX Teach

  This effect will gradually apply Technique Points earned in battle to a
  specific spell or combat technique in [Arg0]. Techniques will automatically
  gain levels during combat just as if they were normally performed or casted.
  
  When a player begins learning a technique for the first time, the spell or
  skill starts out at Level 0 or 0% and can not yet be used by the player. The
  player must accumulate enough Technique Points (set via the spell's $Learn
  value) to get over the initial learning rate for the technique. Once the
  learning time is complete, the spell is usable at Level 0 (with 0 mastery
  points) or the skill is available at 1% Mastery. Languages can only be
  selected for use at 10% Mastery or higher.

  Note: Equipped weapons automatically teach their "Weapon Proficiency" levels
        to the wearer at the end of every battle. This EQFX need not be set on
        weapons to accomodate this value.
  
Syntax:

  Arguments: <Technique Type>,<Technique>,<Limit>

  [Arg0] Technique Type: Only the following types can be applied by this EQFX.
         Types may be abbreviated:

                 Language                   Weapon Proficiency
                 Skills                     Prayers
                 Spells                     Powers
                 Techniques

  [Arg1] Technique: A valid technique entry (spell, skill, etc.) for the type
         in [Arg0] must be specified.

  [Arg2] Limit: The highest level or mastery percentage that this effect will
         teach to the wearer. Spell levels can not go higher than 10 and skills
         can not be learned above 100%. If 0, normal spell/skill limits apply.

Example:

  Skill,Leftwield,75  => Twin Blades; Increases the player's skill of Leftwield
                         up to a maximum of 75% while equipped.

See also: @list Techniques, $Learn

&& EQFX Nullify, Combat

8. EQFX Nullify

  This effect nullifies incoming damage against the wearer when damage is at or
  below a certain specified amount. Damage types can be Hit Points, Magic Power,
  Endurance, or all three. All damage that is nullified during an attack shows
  up in the room as a white '0' and not as a Miss or a Ping.

Syntax:

  Arguments: <Flags>,<Value>

  [Arg0] Types: (one of the following)
    Fixed   - (Default) Nullify damage below a fixed value specified in [Arg1].
    Percent - [Arg1] is a percentage of the player's Maximum HP/MP/EN.
    Divide  - Nullify all damage below the Maximum HP/MP/EN divided by [Arg1].

  [Arg0] Flags: (combine one of the following)
    HP      - All attacks that damage Hit Points (Default).
    MP      - All attacks that damage Magic Power.
    EN      - All attacks that damage Endurance.

  [Arg1] Value: The actual value at which incoming damage is to be nullified.

Examples:

  Fixed+HP,20  => Miracle Dress; Blocks all attacks that do 20 or less damage.
  Divide+MP,4  => Sorcerer's Cap; Protects from MP attacks up to 1/4th MaxMP.

&& EQFX Levelup, Combat

9. EQFX Levelup

  This effect applies a modifier to the average Status Attribute increase of a
  player at time of levelup. The modifier is specified as a positive or
  negative amount in [Arg1], and no percentages or fractions are allowed.

  While normal status variables increase during levelup, this effect can also
  increase less common variables such as # Attacks. Only the attributes shown
  in 'help Status Attributes' can be selected for modification.

Syntax:

  Arguments: <Status Attribute>,<Value>

  [Arg0] Status Attribute: Must be a combat variable from 0 to 31 listed on the
         'help Status Attributes' page. They can be specified using either the
         abbreviation or the full attribute name. Attributes 32 to 63, or
         calculated variables such as Attack Power and Evade %, are not stored
         in the player's bitmap and cannot have modifications applied to them.

  [Arg1] Value: The actual value to be applied to the status attribute.
         Negative values can be used to diminish levelup calculations for a
         specific stat, however a stat can not decrease at the time of levelup.

Examples:

  STR,1    => Power Bracelet; Increases the wearer's Strength by 1 per levelup.
  MAXHP,4  => Phoenix Esper; While equipped, Max HP increases by 4 every level.

See also: Status Attributes

&& EQFX Tactics, Combat

10. EQFX Tactics

  This effect adds a temporary tactics technique to the player currently
  equipping the item. This EQFX allows the same arguments, tactics types, and
  flags as used in the @tactics command, except that a text function cannot be
  specified. EQFX Tactics are applied with a lower priority for the search
  order than the tactics list entries set on the player.

Syntax:

  Arguments: <Tactics Type>,<Technique>,<Rate>,<Flags>

  [Arg0] Tactics Type: (one of the following)
    Fight     - (Default) Chosen at the beginning of a round, this begins
                casting/performing of the technique specified in [Arg1] with
                full casting time.
    Special   - A technique that executes at the end of a round in place of a
                regular attack with no casting delay or decision time penalty.
    Reprisal  - A rebound attack that triggers when struck by an enemy.
    On-Death  - An attack that triggers on your last breath when you perish.

  [Arg1] Technique: A valid combat technique must be specified.

  [Arg2] Rate: The rate of triggering this technique from 0 to 1000. If 0 is
         entered, this tactic is always triggered.

  [Arg3] Flags: The same flags as in @tactics are available in this EQFX.
         Use zero or more of the following:
    0 to 7    - Rate of learning the specified technique via the "Watch Enemy"
                skill. Normally not used on player equipment.
    Secret    - Technique is unavailable to an enemy controlling the player.
    Free      - Player can use this technique without MP/EN/Item Consumption.
    Reverse   - Reverses the natural target of this technique; curative spells
                target enemies, and offensive attacks target oneself.
    Quiet     - Suppresses -< Battle >- messages for this technique in combat.
    Nearfatal - Triggers only when HP is below 25% of the player's Maximum HP.
                This is useful since functions, unlike @tactics, cannot be
                specified individually on EQFX.
    Leader    - Always targets curative techniques at the party leader instead
                of oneself.

Example:

  Special,Riot Blade,50,Free+Nearfatal  => Gives a 1 in 20 chance of using Riot
                                           Blade when HP are less than 25%.

See also: @tactics

&& EQFX Ability, Combat

11. EQFX Ability

  This effect includes a list of Equipment Effects from another spell in the
  item database. Its primary purpose is to facilitate customizing weapons and
  armor with groups of abilities using one Equipment Effect slot. This lets
  shops add or remove complex abilities to players' equipment, or temporarily
  enchant an item with multiple EQFX using a single Semaphore Queue entry.

  Setting a spell's $type to 'Ability' can be used to designate that it is only
  meant to have its EQFX list included by other equipment, however any spell
  in the range 0 to 9999 can be included.

Syntax:

  Arguments: <Spell Number>

  [Arg0] Spell: The number of the spell entry in the item database to include
         Equipment Effects.

  Note: It is advantageous to name spell entries describing their ability. For
        instance, an ability that increases Maximum Magic Power could be named
        'Max MP +10%', or one that applies a Lightning element could be called
        'Lightningrod'.

See also: @list Types

&& EQFX Element, Combat

12. EQFX Element

  This effect modifies the base damage a target can receive from a specific
  element or attack type.
  
  The actual damage dealt to a target is multiplied by three separate
  percentages, all of which begin at 100%. The first percentage is a combined
  average of all attack elements, from Fire to Slash (with the exception of
  Cure). The second percentage is either Physical or Magical, depending on the
  nature of the attack. The third percentage is the Cure element, which is only
  multiplied when the player is the target of a curative spell.

  18 element types, including Physical and Magical, can be selected as shown:
  
          Fire     Water       Cure      Void
          Ice      Lightning   Drain     Bludgeon
          Wind     Shadow      Acid      Pierce
          Earth    Holy        Psionic   Slash

              Physical             Magical

Syntax:

  Arguments: <Element>,<Flags>,<Value>

  [Arg0] Element: One of the above 18 types for modifing base damage.

  [Arg1] Types: (one of the following)
    Fixed     - (Default) Player's base damage is set to the value in [Arg2].
    Modify    - Value in [Arg2] is added/subtracted to the base damage.
    Permanent - Base damage is set to [Arg2], disregarding all other elemental
                modifications by other equipment. Equipment at the top of the
                'equip' list gets priority over lower items.
    Lowest    - Base damage is set to [Arg2] only if the resulting value is
                higher than [Arg2]. This value takes precedence over any
                "Highest" types set by other equipment.
    Highest   - Base damage is set to [Arg2] only if the resulting value is
                lower than [Arg2].

  [Arg2] Value: The value to be applied to the player's base elemental damage.

Examples:
  
  Fire,Lowest,80     => Fire Ward; Decreases damage caused by fire to 80%.
  Physical,Fixed,50  => Astral Belt; all physical damage towards the wearer is
                        halved.
  Cure,Lowest,10     => Wizard's Bane; forces all curative items or spells to
                        operate at 10% or lower when used on the wearer.

See also: EQFX Condition

& New Stuff

  This will be described in the helptext as 'Players have a 1.5-second grace
  period to type in commands after their previous round triggers. The player
  will not be penalized for time wasted for up to 1.5 seconds.'

& Copyright

  TinyMARE Helptext : Copyright © 2003 by Byron Stanoszek
  Last Index Update : February 9, 2003
  Helptext Revision : v3.0

  This helptext documentation archive may be copied, redistributed, or modified
  providing that this copyright remain attached in the file under the Copyright
  topic. The author reserves all rights to make changes to this file and/or the
  copyright.

  vim:tw=79 ts=8 et ft=mare:
